<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNQ Network Plotting Dashboard - Grouped Layout</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script>
        // Ensure D3.js is loaded and has required functions
        if (typeof d3 === 'undefined') {
            console.error('D3.js failed to load');
        } else {
            console.log('D3.js loaded successfully, version:', d3.version);
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
  
        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: #2c3e50;
            line-height: 1.6;
            min-height: 100vh;
        }
  
        .dashboard-container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .main-content {
            flex: 1;
            overflow: auto;
            transition: margin-left 0.2s ease;
        }
  
        .sidebar {
            width: 340px;
            min-width: 280px;
            max-width: 600px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            box-shadow: 4px 0 20px rgba(0,0,0,0.1);
            position: relative;
            transition: width 0.2s ease;
        }

        .sidebar-resize-handle {
            position: absolute;
            right: -5px;
            top: 0;
            width: 10px;
            height: 100%;
            cursor: col-resize;
            background: transparent;
            z-index: 1000;
        }

        .sidebar-resize-handle:hover {
            background: rgba(66, 165, 245, 0.2);
        }

        .sidebar-resize-handle:active {
            background: rgba(66, 165, 245, 0.4);
        }

        .sidebar-toggle-btn {
            position: absolute;
            right: -30px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 60px;
            background: #42a5f5;
            border: none;
            border-radius: 0 8px 8px 0;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
        }

        .sidebar-toggle-btn:hover {
            background: #1976d2;
            width: 35px;
        }

        .sidebar.collapsed {
            width: 0;
            min-width: 0;
            overflow: hidden;
        }

        .sidebar.collapsed .sidebar-content {
            opacity: 0;
        }

        .sidebar.collapsed .header {
            opacity: 0;
        }
  
        .header {
            background: linear-gradient(135deg, #42a5f5 0%, #1976d2 100%);
            color: white;
            padding: 1.5rem 1rem;
            text-align: center;
        }
  
        .header h1 {
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
  
        .header .subtitle {
            font-size: 0.9rem;
            opacity: 0.9;
            font-weight: 300;
        }
  
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }
  
        .section {
            margin-bottom: 1.5rem;
            background: white;
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            overflow-x: visible;
        }
  
        .section h3 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #2c3e50;
            border-bottom: 2px solid #42a5f5;
            padding-bottom: 0.5rem;
        }
  
        .file-input {
            margin-bottom: 1rem;
        }
  
        .file-input label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #6c757d;
            font-size: 0.9rem;
        }
  
        .file-input input[type="file"] {
            width: 100%;
            padding: 0.75rem;
            border: 2px dashed #cbd5e0;
            border-radius: 8px;
            background: #f8f9fa;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }
  
        .file-input input[type="file"]:hover {
            border-color: #42a5f5;
            background: white;
        }
  
        .status {
            padding: 0.75rem;
            margin-top: 0.5rem;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 500;
        }
  
        .status.success {
            background: #d4edda;
            color: #155724;
            border-left: 4px solid #28a745;
        }
  
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border-left: 4px solid #dc3545;
        }
  
        .status.processing {
            background: #d1ecf1;
            color: #0c5460;
            border-left: 4px solid #17a2b8;
        }
  
        .btn {
            background: linear-gradient(135deg, #42a5f5 0%, #1976d2 100%);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            width: 100%;
        }
  
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.6);
        }
  
        .btn:disabled {
            background: #e9ecef;
            color: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
  
        .control-group {
            margin-bottom: 0.75rem;
        }
  
        .control-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #495057;
            font-size: 0.9rem;
        }
  
        .control-group select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ced4da;
            border-radius: 6px;
            background: white;
            font-size: 0.9rem;
        }
  
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
  
        .checkbox-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }
  
        .main-content {
            flex: 1;
            position: relative;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            height: 100vh;
            overflow: hidden;
        }
  
        .network-svg {
            width: 100%;
            height: 100vh;
        }
  
        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(10px);
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            min-width: 200px;
        }
  
        .legend h4 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #2c3e50;
            text-align: center;
        }
  
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            font-weight: 500;
        }
  
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.2);
        }
  
        .info-panel {
            position: absolute;
            background: rgba(255,255,255,0.98);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            max-height: 70vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            display: none;
            z-index: 1000;
        }
  
        .info-panel h3 {
            margin-bottom: 1.5rem;
            color: #2c3e50;
            font-size: 1.3rem;
            font-weight: 700;
            border-bottom: 3px solid #42a5f5;
            padding-bottom: 0.5rem;
        }
  
        .info-row {
            display: grid;
            grid-template-columns: 1fr 1.5fr;
            gap: 1rem;
            margin-bottom: 0.75rem;
            padding: 0.5rem 0;
            border-bottom: 1px solid #f1f3f4;
        }
  
        .info-label {
            font-weight: 600;
            color: #495057;
        }
  
        .info-value {
            color: #2c3e50;
            font-weight: 500;
        }
  
        .context-box {
            cursor: pointer;
        }
  
        .context-box.clickable {
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.2));
        }
  
        .alter-node {
            cursor: pointer;
        }
  
        .ego-node {
            filter: drop-shadow(0 6px 12px rgba(231, 76, 60, 0.4));
        }
  
        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-size: 0.85rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 2000;
            max-width: 250px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
            display: none !important;
            visibility: hidden !important;
        }
  
        .breadcrumb {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255,255,255,0.9);
            backdrop-filter: blur(10px);
            padding: 0.75rem 1.5rem;
            border-radius: 25px;
            font-weight: 500;
            color: #495057;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            z-index: 100;
        }
  
        .close-panel {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6c757d;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
  
        .close-panel:hover {
            background: #f8f9fa;
            color: #495057;
        }
  
        /* Node selection states */
        .node--selected circle {
            fill: #ef4444 !important;
            stroke-width: 3px !important;
        }
  
        .node--neighbor circle {
            fill: #fb923c !important;
            stroke-width: 3px !important;
        }
  
        /* Edge states */
        .edge--active {
            stroke: #ef4444 !important;
            stroke-width: 3.5px !important;
            opacity: 0.5 !important;
        }
  
        /* Ensure proper layering - no z-index for SVG */
        .background-layer {
            /* Background elements (context boxes, ego connectors) */
        }
  
        .edges-layer {
            /* Edges layer - above background, below nodes */
        }
  
        .nodes-layer {
            /* Nodes layer - on top */
        }
  
        /* Range slider styling */
        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
  
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #42a5f5;
            cursor: pointer;
        }
  
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #42a5f5;
            cursor: pointer;
            border: none;
        }
  
        /* Floating cards */
        .floating-card {
            position: fixed;
            background: rgba(255,255,255,0.98);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 16px;
            padding: 1.2rem;
            max-width: 300px;
            max-height: 60vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            z-index: 2000;
            bottom: 20px;
            right: 20px;
            font-size: 0.9rem;
            line-height: 1.35;
        }
  
        .floating-card h3 {
            margin-bottom: 0.8rem;
            color: #2c3e50;
            font-size: 1rem;
            font-weight: 700;
            border-bottom: 2px solid #42a5f5;
            padding-bottom: 0.4rem;
        }
  
        .floating-card .info-label {
            font-size: 0.85rem;
            font-weight: 600;
        }
  
        .floating-card .info-value {
            font-size: 0.9rem;
        }
  
        /* Enhanced legend system */
        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(10px);
            padding: 1.2rem;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            min-width: 200px;
            max-width: 280px;
        }
  
        .legend-section {
            margin-bottom: 1.2rem;
        }
  
        .legend-section:last-child {
            margin-bottom: 0;
        }
  
        .legend-section h4 {
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 0.8rem;
            color: #2c3e50;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 0.4rem;
        }
  
        .size-legend-item {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            margin-bottom: 0.4rem;
            font-size: 0.8rem;
        }
  
        .size-circle {
            border-radius: 50%;
            background: #ccc;
            border: 1px solid #999;
            flex-shrink: 0;
        }
  
        /* Data processed banner */
        .success-banner {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
        }
  
        /* Responsive grid for summary tiles */
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: 12px;
            margin-bottom: 1rem;
        }
  
        /* Help overlay */
        .help-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 3000;
            display: none;
        }
  
        .help-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 16px;
            padding: 2rem;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
  
        /* Subtle hover effects only - no movement */
        .alter-node:hover circle {
            stroke-width: 5px;
        }
  
        /* Search highlighting */
        .alter-node.search-match circle {
            stroke: #ff6b35 !important;
            stroke-width: 4px !important;
            filter: drop-shadow(0 2px 4px rgba(255, 107, 53, 0.4));
        }
  
        /* Survey respondent indicator */
        .alter-node.survey-respondent {
            position: relative;
        }
        
        .alter-node.survey-respondent::after {
            content: '★';
            position: absolute;
            top: -5px;
            right: -5px;
            color: #ffd700;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            z-index: 10;
        }
  
        /* Page routing and transitions */
        .page {
            transition: opacity 200ms ease-in-out;
            min-height: 100vh;
        }
  
        .page.hidden {
            opacity: 0;
            pointer-events: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            z-index: -1;
        }
  
        /* Welcome page */
        .welcome-page {
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            padding: 2rem;
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
        }
        
        /* University of Chicago Logo Styles */
        .uchicago-logo {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 2rem;
        }
        
        .logo-image {
            max-width: 450px;
            height: auto;
            filter: drop-shadow(0 4px 15px rgba(0, 0, 0, 0.1));
        }
  
        .welcome-card {
            background: white;
            border-radius: 16px;
            padding: 3rem;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            max-width: 800px;
            width: 100%;
            text-align: center;
        }
  
        .welcome-title {
            font-size: 2.5rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #42a5f5 0%, #1976d2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
  
        .welcome-subtitle {
            font-size: 1.2rem;
            color: #6c757d;
            margin-bottom: 2.5rem;
            line-height: 1.6;
        }
  
        .upload-zones {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
  
        .upload-zone {
            border: 2px dashed #cbd5e0;
            border-radius: 12px;
            padding: 2rem 1rem;
            background: #f8f9fa;
            transition: all 0.3s ease;
            cursor: pointer;
            text-align: center;
        }
  
        .upload-zone:hover {
            border-color: #42a5f5;
            background: white;
            box-shadow: 0 4px 15px rgba(66, 165, 245, 0.1);
        }
  
        .upload-zone.loaded {
            border-color: #28a745;
            background: #d4edda;
        }
  
        .upload-zone.error {
            border-color: #dc3545;
            background: #f8d7da;
        }
  
        .upload-zone h4 {
            margin: 0 0 0.5rem 0;
            color: #495057;
            font-weight: 600;
        }
  
        .upload-zone p {
            margin: 0 0 1rem 0;
            font-size: 0.9rem;
            color: #6c757d;
        }
  
        .upload-status {
            font-size: 0.85rem;
            font-weight: 500;
            margin-top: 0.5rem;
        }
  
        .upload-status.success {
            color: #155724;
        }
  
        .upload-status.error {
            color: #721c24;
        }
  
        .process-button {
            background: linear-gradient(135deg, #42a5f5 0%, #1976d2 100%);
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(66, 165, 245, 0.4);
            margin: 1rem 0;
        }
  
        .process-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(66, 165, 245, 0.6);
        }
  
        .process-button:disabled {
            background: #e9ecef;
            color: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
  
        .sample-link {
            color: #42a5f5;
            text-decoration: none;
            font-size: 0.9rem;
            margin-top: 1rem;
            display: inline-block;
        }
  
        .sample-link:hover {
            text-decoration: underline;
        }
  
        /* Validation page */
        .validation-page {
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            padding: 2rem;
            min-height: 100vh;
        }
  
        .validation-card {
            background: white;
            border-radius: 16px;
            padding: 2.5rem;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            max-width: 700px;
            width: 100%;
        }
  
        .validation-header {
            text-align: center;
            margin-bottom: 2rem;
        }
  
        .validation-status {
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            text-align: center;
            font-weight: 600;
        }
  
        .validation-status.pass {
            background: #d4edda;
            color: #155724;
        }
  
        .validation-status.fail {
            background: #f8d7da;
            color: #721c24;
        }
  
        .validation-file {
            margin-bottom: 1.5rem;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 1rem;
        }
  
        .validation-file h4 {
            margin: 0 0 0.75rem 0;
            color: #495057;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
  
        .validation-check {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }
  
        .check-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }
  
        .check-icon.pass {
            background: #28a745;
            color: white;
        }
  
        .check-icon.fail {
            background: #dc3545;
            color: white;
        }
  
        .validation-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 2rem;
        }
  
        /* Mode selection page */
        .mode-page {
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            padding: 2rem;
            min-height: 100vh;
        }
  
        .mode-card {
            background: white;
            border-radius: 16px;
            padding: 2.5rem;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            max-width: 600px;
            width: 100%;
            text-align: center;
        }
  
        .mode-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            margin: 2rem 0;
        }
  
        .mode-option {
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 2rem 1.5rem;
            transition: all 0.3s ease;
            cursor: pointer;
        }
  
        .mode-option:hover:not(.disabled) {
            border-color: #667eea;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.1);
        }
  
        .mode-option.disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
  
        .mode-option h3 {
            margin: 0 0 1rem 0;
            color: #2c3e50;
        }
  
        .mode-option p {
            margin: 0 0 1.5rem 0;
            color: #6c757d;
            font-size: 0.9rem;
            line-height: 1.5;
        }
  
        .mode-button {
            background: linear-gradient(135deg, #42a5f5 0%, #1976d2 100%);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
  
        .mode-button:hover {
            transform: translateY(-1px);
        }
  
        .mode-button:disabled {
            background: #e9ecef;
            color: #6c757d;
            cursor: not-allowed;
            transform: none;
        }
  
        .back-link {
            color: #42a5f5;
            text-decoration: none;
            font-size: 0.9rem;
            margin-top: 1.5rem;
            display: inline-block;
        }
  
        .back-link:hover {
            text-decoration: underline;
        }
  
        /* Dataset placeholder page */
        .dataset-page {
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            padding: 2rem;
            min-height: 100vh;
        }
  
        .dataset-card {
            background: white;
            border-radius: 16px;
            padding: 2.5rem;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            max-width: 400px;
            width: 100%;
            text-align: center;
        }
        
        /* Whole Data Exploration Page */
        .whole-data-page {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            min-height: 100vh;
        }
        
        .whole-data-page .dashboard-container {
            height: calc(100vh - 60px);
        }
        
        .whole-data-page .main-content {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
        }
        
        .plot-container {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .plot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #42a5f5;
        }
        
        .plot-header h3 {
            margin: 0;
            color: #2c3e50;
            font-size: 1.3rem;
        }
        
        .stats-panel {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid #42a5f5;
            font-size: 0.9rem;
            color: #495057;
        }
        
        .chart-area {
            min-height: 400px;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
        }
        
        .welcome-message {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 60vh;
        }
        
        .welcome-card {
            background: white;
            padding: 3rem;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            text-align: center;
            max-width: 600px;
        }
        
        .welcome-card h2 {
            color: #2c3e50;
            margin-bottom: 1rem;
            font-size: 2rem;
        }
        
        .welcome-card p {
            color: #6c757d;
            margin-bottom: 2rem;
            line-height: 1.6;
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            margin-top: 2rem;
        }
        
        .feature-item {
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 12px;
            border-left: 4px solid #42a5f5;
        }
        
        .feature-item h4 {
            color: #2c3e50;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }
        
        .feature-item p {
            color: #6c757d;
            font-size: 0.9rem;
            margin: 0;
        }
  
        /* Breadcrumb */
        .breadcrumb {
            position: fixed;
            top: 80px;
            left: 400px;
            background: rgba(255,255,255,0.9);
            backdrop-filter: blur(10px);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.85rem;
            color: #495057;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            z-index: 1000;
            transition: all 0.3s ease;
            cursor: move;
            user-select: none;
            min-width: 300px;
            white-space: nowrap;
        }
        
        .breadcrumb.collapsed {
            width: 60px;
            overflow: hidden;
            transition: width 0.3s ease;
        }
        
        .breadcrumb.collapsed .breadcrumb-content,
        .breadcrumb.collapsed .screenshot-controls {
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .breadcrumb.collapsed .header-controls {
            opacity: 1;
            transition: opacity 0.3s ease;
        }
        
        .breadcrumb-content {
            display: inline-block;
        }
        
        .header-controls {
            display: inline-block;
            margin-left: 15px;
            vertical-align: middle;
            opacity: 1;
            transition: opacity 0.3s ease;
            position: relative;
            z-index: 1001;
        }
        
        .toggle-header-btn, .move-header-btn {
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 4px;
            padding: 2px 6px;
            margin: 0 2px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
            display: inline-block !important;
            visibility: visible !important;
        }
        
        .toggle-header-btn:hover, .move-header-btn:hover {
            background: rgba(102, 126, 234, 0.2);
            border-color: rgba(102, 126, 234, 0.5);
        }
        
        .breadcrumb.dragging {
            opacity: 0.8;
            transform: scale(1.02);
        }
  
        .breadcrumb a {
            color: #42a5f5;
            text-decoration: none;
        }
  
        .breadcrumb a:hover {
            text-decoration: underline;
        }
        
        /* Screenshot Controls in Breadcrumb */
        .screenshot-controls {
            margin-left: 20px;
        }
        
        .screenshot-controls select {
            border: 1px solid #ced4da;
            border-radius: 4px;
            padding: 0.3rem;
            font-size: 0.85rem;
            background: white;
        }
        
        .screenshot-controls .btn {
            background: #42a5f5;
            color: white;
            border: none;
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background-color 0.2s ease;
        }
        
        .screenshot-controls .btn:hover {
            background: #5a6fd8;
        }
  
        /* Data processed chip */
        .data-chip {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            text-align: center;
            margin-bottom: 1rem;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
        }
  
        /* Sidebar Navigation Tabs */
        .sidebar-nav {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #e5e7eb;
        }
  
        .nav-tab {
            flex: 1;
            min-width: fit-content;
            padding: 0.5rem 0.6rem;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            white-space: nowrap;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            color: #374151;
        }
  
        .nav-tab:hover {
            background: #f8fafc;
            border-color: #42a5f5;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(66, 165, 245, 0.2);
        }
  
        .nav-tab.active {
            background: linear-gradient(135deg, #42a5f5 0%, #1976d2 100%);
            color: white;
            border-color: #1976d2;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(66, 165, 245, 0.3);
        }
  
        .sidebar-section {
            display: none;
        }
  
        .sidebar-section.active {
            display: block;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .sidebar {
                width: 300px;
                min-width: 260px;
            }
            
            .header h1 {
                font-size: 1.2rem;
            }
            
            .sidebar-content {
                padding: 0.75rem;
            }
            
            .section {
                padding: 0.75rem;
                margin-bottom: 1rem;
            }
            
            .nav-tab {
                font-size: 0.8rem;
                padding: 0.4rem 0.5rem;
                min-width: fit-content;
            }
        }

        @media (max-width: 768px) {
            .sidebar {
                width: 280px;
                min-width: 240px;
            }
            
            .header h1 {
                font-size: 1.1rem;
            }
            
            .sidebar-content {
                padding: 0.5rem;
            }
            
            .section {
                padding: 0.5rem;
                margin-bottom: 0.75rem;
            }
            
            .nav-tab {
                font-size: 0.75rem;
                padding: 0.35rem 0.45rem;
                min-width: fit-content;
            }
        }
  
        /* Resizable moveable details panel for selected alter */
        .resizable-details-panel {
            position: absolute;
            top: 320px;
            right: 20px;
            width: 280px;
            min-width: 250px;
            max-width: 500px;
            min-height: 200px;
            max-height: calc(100vh - 360px);
            background: rgba(255,255,255,0.98);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            z-index: 1500;
            display: none;
            overflow: hidden;
            cursor: move;
        }
  
        .resizable-details-panel .panel-header {
            padding: 1rem 1.5rem 0.5rem 1.5rem;
            border-bottom: 2px solid #42a5f5;
            margin-bottom: 1rem;
            cursor: move;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
  
        .resizable-details-panel .panel-header h3 {
            margin: 0;
            color: #2c3e50;
            font-size: 1rem;
            font-weight: 700;
        }
  
        .resizable-details-panel .panel-content {
            padding: 0 1.5rem 1.5rem 1.5rem;
            overflow-y: auto;
            height: 300px;
            max-height: calc(100vh - 420px);
            font-size: 0.9rem;
            line-height: 1.4;
        }
  
        .resizable-details-panel .info-row {
            display: flex;
            flex-direction: column;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #e9ecef;
        }
  
        .resizable-details-panel .info-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: #495057;
            margin-bottom: 0.25rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
  
        .resizable-details-panel .info-value {
            font-size: 0.95rem;
            color: #2c3e50;
            line-height: 1.3;
            word-break: break-word;
            hyphens: auto;
        }
  
        .resizable-details-panel .close-btn {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            color: #6c757d;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
  
        .resizable-details-panel .close-btn:hover {
            background: #f8f9fa;
            color: #495057;
        }
  
        /* Resize handles for all edges */
        .resizable-details-panel {
            resize: none; /* Disable default resize */
        }
  
        .resizable-details-panel .resize-handle {
            position: absolute;
            background: transparent;
            z-index: 10;
        }
  
        .resizable-details-panel .resize-handle-n {
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            cursor: n-resize;
        }
  
        .resizable-details-panel .resize-handle-s {
            bottom: 0;
            left: 0;
            right: 0;
            height: 5px;
            cursor: s-resize;
        }
  
        .resizable-details-panel .resize-handle-e {
            top: 0;
            right: 0;
            bottom: 0;
            width: 5px;
            cursor: e-resize;
        }
  
        .resizable-details-panel .resize-handle-w {
            top: 0;
            left: 0;
            bottom: 0;
            width: 5px;
            cursor: w-resize;
        }
  
        .resizable-details-panel .resize-handle-ne {
            top: 0;
            right: 0;
            width: 10px;
            height: 10px;
            cursor: ne-resize;
        }
  
        .resizable-details-panel .resize-handle-nw {
            top: 0;
            left: 0;
            width: 10px;
            height: 10px;
            cursor: nw-resize;
        }
  
        .resizable-details-panel .resize-handle-se {
            bottom: 0;
            right: 0;
            width: 10px;
            height: 10px;
            cursor: se-resize;
        }
  
        .resizable-details-panel .resize-handle-sw {
            bottom: 0;
            left: 0;
            width: 10px;
            height: 10px;
            cursor: sw-resize;
        }
  
        /* Visual indicator for the bottom-right resize handle */
        .resizable-details-panel .resize-handle-se::after {
            content: '';
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-bottom: 8px solid #ccc;
            opacity: 0.6;
        }
  
        /* Fixed details panel - COMPLETELY REWRITTEN */
        .fixed-details-panel {
            position: absolute;
            left: 20px;
            top: 80px;
            width: 320px;
            max-height: calc(100vh - 120px);
            background: rgba(255,255,255,0.98);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            z-index: 1500;
            overflow-y: auto;
            overflow-x: hidden;
            display: none;
            font-size: 0.9rem;
            line-height: 1.4;
        }
  
        .fixed-details-panel h3 {
            margin-bottom: 1rem;
            color: #2c3e50;
            font-size: 1rem;
            font-weight: 700;
            border-bottom: 2px solid #42a5f5;
            padding-bottom: 0.5rem;
        }
  
        .fixed-details-panel .info-row {
            display: flex;
            flex-direction: column;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #e9ecef;
        }
  
        .fixed-details-panel .info-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: #495057;
            margin-bottom: 0.25rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
  
        .fixed-details-panel .info-value {
            font-size: 0.95rem;
            color: #2c3e50;
            line-height: 1.3;
            word-break: break-word;
            hyphens: auto;
        }
    </style>
  </head>
  <body>
    <!-- Welcome Page -->
    <div id="welcomePage" class="page welcome-page hidden">
        <div class="welcome-card">
            <!-- University of Chicago Logo -->
            <div class="uchicago-logo">
                <img src="image.png" alt="University of Chicago Logo" class="logo-image">
            </div>
            
            <h1 class="welcome-title">SNQ Network Plotting Dashboard</h1>
            <p class="welcome-subtitle">Upload your study files to explore child social networks. We'll validate formats before visualization.</p>
            
            <div class="upload-zones">
                <div class="upload-zone loaded" onclick="document.getElementById('longDfFile').click()">
                    <h4>Alter Data</h4>
                    <p>long_df.csv</p>
                    <input type="file" id="longDfFile" accept=".csv" style="display: none;">
                    <div id="longDfStatus" class="upload-status success">✓ Loaded 21 rows</div>
            </div>
  
                <div class="upload-zone loaded" onclick="document.getElementById('networkWideFile').click()">
                    <h4>Child Data</h4>
                    <p>network_wide.csv</p>
                    <input type="file" id="networkWideFile" accept=".csv" style="display: none;">
                    <div id="networkWideStatus" class="upload-status success">✓ Loaded 2 rows</div>
                </div>
                
                <div class="upload-zone loaded" onclick="document.getElementById('activityLongFile').click()">
                    <h4>Activity Data</h4>
                    <p>activity_long.csv</p>
                    <input type="file" id="activityLongFile" accept=".csv" style="display: none;">
                    <div id="activityLongStatus" class="upload-status success">✓ Loaded 2 rows</div>
                </div>
                    </div>
  
            <button class="process-button" id="processBtn" onclick="processData()">
                Process &amp; Validate
            </button>
            
            <a href="#" class="sample-link" onclick="showSampleFormats()">View sample file formats</a>
        </div>
                    </div>
  
    <!-- Validation Page -->
    <div id="validatePage" class="page validation-page hidden">
        <div class="validation-card">
            <div class="validation-header">
                <h2>Data Validation</h2>
                    </div>
  
            <div id="validationStatus" class="validation-status pass">✅ All checks passed<br><span style="color: #155724;">Your data look good.</span></div>
            
            <div id="validationResults">
                    <div class="validation-file">
                        <h4>
                            <div class="check-icon pass">✓</div>
                            long_df.csv
                        </h4>
                        
                    <div class="validation-check">
                        <div class="check-icon pass">
                            ✓
                        </div>
                        <span>Required columns present</span>
                    </div>
                
                    <div class="validation-check">
                        <div class="check-icon pass">
                            ✓
                        </div>
                        <span>Data integrity</span>
                    </div>
                
                        
                    </div>
                
                    <div class="validation-file">
                        <h4>
                            <div class="check-icon pass">✓</div>
                            network_wide.csv
                        </h4>
                        
                    <div class="validation-check">
                        <div class="check-icon pass">
                            ✓
                        </div>
                        <span>Required columns present</span>
                    </div>
                
                    <div class="validation-check">
                        <div class="check-icon pass">
                            ✓
                        </div>
                        <span>Data integrity</span>
                    </div>
                
                        
                    </div>
                
                    <div class="validation-file">
                        <h4>
                            <div class="check-icon pass">✓</div>
                            activity_long.csv
                        </h4>
                        
                    <div class="validation-check">
                        <div class="check-icon pass">
                            ✓
                        </div>
                        <span>Required columns present</span>
                    </div>
                
                    <div class="validation-check">
                        <div class="check-icon pass">
                            ✓
                        </div>
                        <span>Data integrity</span>
                    </div>
                
                        
                    </div>
                </div>
            
            <div class="validation-buttons">
                <button class="process-button" onclick="goToWelcome()">Re-upload Files</button>
                <button class="process-button" id="continueBtn" onclick="goToMode()">Continue</button>
            </div>
        </div>
    </div>
  
    <!-- Mode Selection Page -->
    <div id="modePage" class="page mode-page">
        <div class="mode-card">
            <h2>Choose how to explore</h2>
            
            <div class="mode-options">
                <div class="mode-option" onclick="startChildExploration()">
                    <h3>🧒 Explore by Child</h3>
                    <p>Pick a child and view their network with contexts, ties and filters.</p>
                    <button class="mode-button">Start</button>
                </div>
                
                <div class="mode-option" onclick="startWholeDataExploration()">
                    <h3>📊 Explore Whole Data</h3>
                    <p>Aggregate insights across all children using Distribution and Interaction Explorers.</p>
                    <button class="mode-button">Start</button>
                </div>
            </div>
            
            <a href="#" class="back-link" onclick="goToValidate()">Back to validation</a>
        </div>
    </div>
  
    <!-- Whole Data Exploration Page -->
    <div id="wholeDataPage" class="page whole-data-page hidden">
        <div class="breadcrumb" id="wholeDataBreadcrumb">
            <div class="breadcrumb-content">
                <a href="#" onclick="goToMode()">Home</a> / Mode / Explore Whole Data
            </div>
            <div class="screenshot-controls" style="float: right; display: flex; align-items: center; gap: 10px;">
                <select id="wholeDataScreenshotFormat" style="padding: 0.3rem; border: 1px solid #ced4da; border-radius: 4px; font-size: 0.9rem;">
                    <option value="png">PNG</option>
                    <option value="jpg">JPG</option>
                    <option value="svg">SVG</option>
                </select>
                <button class="btn" onclick="takeWholeDataScreenshot()" style="background: #42a5f5; color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; font-size: 0.9rem;">
                    📸 Screenshot
                </button>
            </div>
            <div class="header-controls">
                <button class="toggle-header-btn" onclick="toggleWholeDataHeader()" title="Toggle header visibility">
                    <span id="wholeDataToggleIcon">▼</span>
                </button>
                <button class="move-header-btn" onmousedown="startWholeDataHeaderDrag(event)" title="Drag to move header">
                    🖐️
                </button>
            </div>
        </div>
        
        <div class="dashboard-container">
            <div class="sidebar" id="wholeDataSidebar">
                <div class="header">
                    <h1>SNQ Network Plotting Dashboard</h1>
                    <div class="subtitle">Whole Data Exploration</div>
                </div>
                
                <!-- Resize Handle -->
                <div class="sidebar-resize-handle" id="wholeDataSidebarResizeHandle"></div>
                
                <!-- Toggle Button -->
                <button class="sidebar-toggle-btn" id="wholeDataSidebarToggleBtn" onclick="toggleWholeDataSidebar()" title="Toggle Sidebar">
                    ◀
                </button>
                
                <div class="sidebar-content">
                    <div class="data-chip">
                        Data processed ✓
                    </div>
                    
                    <div class="section" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                        <h4>💡 Testing Mode</h4>
                        <p style="font-size: 0.9rem; margin: 0;">You can test the exploration features with sample data while uploading your own files. Upload your CSV files on the main page to analyze your real data.</p>
                    </div>
                    
                    <!-- Exploration Mode Selection -->
                    <div class="section">
                        <h3>📊 Exploration Mode</h3>
                        <div class="control-group">
                            <label>Mode:</label>
                            <select id="wholeDataExplorationMode" onchange="updateWholeDataExplorationView()">
                                <option value="distribution">Distribution Explorer</option>
                                <option value="interaction">Interaction Explorer</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Distribution Controls -->
                    <div id="wholeDataDistributionControls" class="section">
                        <h3>📈 Distribution Explorer</h3>
                        <div class="control-group">
                            <label>Variable:</label>
                            <select id="wholeDataDistributionVariable" onchange="updateWholeDataDistributionPlot()">
                                <option value="">Select a variable...</option>
                                <optgroup label="Demographics">
                                    <option value="age_in_months">Age (months)</option>
                                    <option value="child_gender">Gender</option>
                                    <option value="child_race">Race/Ethnicity</option>
                                    <option value="child_lang">Languages</option>
                                </optgroup>
                                <optgroup label="Care Context">
                                    <option value="childcare_yn">Childcare (Y/N)</option>
                                    <option value="childcare_type">Childcare Type</option>
                                    <option value="childcare_start_age">Childcare Start Age</option>
                                    <option value="childcare_size">Group Size</option>
                                </optgroup>
                                <optgroup label="Network Structure">
                                    <option value="network_size">Network Size</option>
                                    <option value="prop_adult_relationship">% Adult Alters</option>
                                    <option value="prop_kin_relationship">% Kin Alters</option>
                                    <option value="network_density">Network Density</option>
                                    <option value="edges_number">Number of Ties</option>
                                    <option value="component_count">Component Count</option>
                                    <option value="component_ratio">Component Ratio</option>
                                </optgroup>
                                <optgroup label="Diversity Indices">
                                    <option value="racial_ei_index">Racial EI Index</option>
                                    <option value="race_entropy">Race Entropy</option>
                                    <option value="linguistic_ei_index">Linguistic EI Index</option>
                                    <option value="language_entropy">Language Entropy</option>
                                </optgroup>
                                <optgroup label="Derived Metrics">
                                    <option value="sibling_size">Sibling Size</option>
                                    <option value="kin_size">Kin Size</option>
                                    <option value="extended_family_presence">Extended Family Presence</option>
                                    <option value="caregiver_presence">Caregiver Presence</option>
                                    <option value="live_at_home_size">Live-at-Home Size</option>
                                    <option value="parent_vs_nonparent_caregiver">Parent vs Non-Parent Caregiver</option>
                                    <option value="pct_male_alters">% Male Alters</option>
                                    <option value="pct_female_alters">% Female Alters</option>
                                    <option value="avg_closeness_score">Average Closeness Score</option>
                                    <option value="max_closeness_score">Max Closeness Score</option>
                                    <option value="min_closeness_score">Min Closeness Score</option>
                                    <option value="avg_weekly_exposure">Average Weekly Exposure</option>
                                    <option value="exposure_by_context">Exposure by Context</option>
                                    <option value="mode_of_contact_proportions">Mode of Contact Proportions</option>
                                    <option value="activity_count">Activity Count</option>
                                    <option value="activity_diversity">Activity Diversity</option>
                                    <option value="pct_activities_with_peers">% Activities with Peers</option>
                                    <option value="activity_language_distribution">Activity Language Distribution</option>
                                </optgroup>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Interaction Controls -->
                    <div id="wholeDataInteractionControls" class="section" style="display: none;">
                        <h3>🔗 Interaction Explorer</h3>
                        <div class="control-group">
                            <label>X Variable:</label>
                            <select id="wholeDataXVariable" onchange="updateWholeDataInteractionPlot()">
                                <option value="">Select X variable...</option>
                            </select>
                            
                            <label>Y Variable:</label>
                            <select id="wholeDataYVariable" onchange="updateWholeDataInteractionPlot()">
                                <option value="">Select Y variable...</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Export Controls -->
                    <div class="section">
                        <h3>📥 Export</h3>
                        <div class="control-group">
                            <label>Format:</label>
                            <select id="wholeDataExportFormat">
                                <option value="png">PNG</option>
                                <option value="svg">SVG</option>
                                <option value="csv">CSV Data</option>
                            </select>
                            <button class="btn" onclick="exportWholeDataPlot()" style="width: 100%; background: #28a745; color: white; border: none; padding: 0.5rem; border-radius: 6px; cursor: pointer;">
                                📥 Export
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="main-content">
                <div id="wholeDataPlotsArea" style="display: none;">
                    <!-- Distribution Plot -->
                    <div id="wholeDataDistributionPlot" class="plot-container">
                        <div class="plot-header">
                            <h3>Distribution Plot</h3>
                            <div id="wholeDataDistributionStats" class="stats-panel"></div>
                        </div>
                        <div id="wholeDataDistributionChart" class="chart-area"></div>
                    </div>
                    
                    <!-- Interaction Plot -->
                    <div id="wholeDataInteractionPlot" class="plot-container" style="display: none;">
                        <div class="plot-header">
                            <h3>Interaction Plot</h3>
                            <div id="wholeDataInteractionStats" class="stats-panel"></div>
                        </div>
                        <div id="wholeDataInteractionChart" class="chart-area"></div>
                    </div>
                </div>
                
                <div id="wholeDataWelcome" class="welcome-message">
                    <div class="welcome-card">
                        <h2>📊 Explore Whole Data</h2>
                        <p>Select an exploration mode and variable to begin analyzing your network data.</p>
                        <div class="feature-grid">
                            <div class="feature-item">
                                <h4>📈 Distribution Explorer</h4>
                                <p>Visualize distributions of individual variables with summary statistics</p>
                            </div>
                            <div class="feature-item">
                                <h4>🔗 Interaction Explorer</h4>
                                <p>Explore relationships between pairs of variables</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
  
    <!-- Child Dashboard Page -->
    <div id="childPage" class="page dashboard-container hidden">
        <div class="breadcrumb" id="breadcrumb">
            <div class="breadcrumb-content">
            <a href="#" onclick="goToMode()">Home</a> / Mode / Explore by Child
            </div>
            <div class="screenshot-controls" style="float: right; display: flex; align-items: center; gap: 10px;">
                <select id="screenshotFormat" style="padding: 0.3rem; border: 1px solid #ced4da; border-radius: 4px; font-size: 0.9rem;">
                    <option value="png">PNG</option>
                    <option value="jpg">JPG</option>
                    <option value="svg">SVG</option>
                </select>
                <button class="btn" onclick="takeScreenshot()" style="background: #42a5f5; color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; font-size: 0.9rem;">
                    📸 Screenshot
                </button>
            </div>
            <div class="header-controls">
                <button class="toggle-header-btn" onclick="toggleHeader()" title="Toggle header visibility">
                    <span id="toggleIcon">▼</span>
                </button>
                <button class="move-header-btn" onmousedown="startHeaderDrag(event)" title="Drag to move header">
                    🖐️
                </button>
            </div>
        </div>
        
        <div class="sidebar" id="sidebar">
            <div class="header">
                <h1>SNQ Network Plotting Dashboard</h1>
                <div class="subtitle" onclick="showHelp()" style="cursor: pointer; text-decoration: underline;">Help & Tips</div>
            </div>
            
            <!-- Resize Handle -->
            <div class="sidebar-resize-handle" id="sidebarResizeHandle"></div>
            
            <!-- Toggle Button -->
            <button class="sidebar-toggle-btn" id="sidebarToggleBtn" onclick="toggleSidebar()" title="Toggle Sidebar">
                ◀
            </button>
  
            <div class="sidebar-content">
                <div class="data-chip">
                    Data processed ✓
                </div>
  
                <!-- Navigation Tabs -->
                <div class="sidebar-nav">
                    <button class="nav-tab" onclick="showSidebarSection('child-selection')">Child Selection</button>
                    <button class="nav-tab" onclick="showSidebarSection('child-info')">Child Info</button>
                    <button class="nav-tab" onclick="showSidebarSection('display-controls')">Display</button>
                    <button class="nav-tab" onclick="showSidebarSection('network-stats')">Stats</button>
                    <button class="nav-tab" onclick="showSidebarSection('filters')">Filters</button>
                </div>
  
                <div class="section sidebar-section" id="child-selection" style="display: none;">
                    <h3>Child Selection</h3>
                    
                    <div class="control-group">
                        <label>Select Child:</label>
                        <select id="childSelect" onchange="updateChildSelection()"><option value="">Choose a child...</option><option value="Testing">Testing - Orca</option><option value="test">test - test</option></select>
                    </div>
  
                    <button class="btn" onclick="visualizeNetwork()" id="visualizeBtn" disabled="">
                        Visualize Network
                    </button>
                    
                    <a href="#" onclick="goToMode()" style="font-size: 0.85rem; color: #42a5f5; text-decoration: none; margin-top: 0.5rem; display: block;">Change child</a>
                </div>
  
                <div class="section sidebar-section" id="child-info" style="display: none;">
                    <h3>Child Information</h3>
                    <div id="sidebarChildInfo">
                <div class="info-row">
                    <span class="info-label">Name:</span>
                    <span class="info-value">Orca</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Age:</span>
                    <span class="info-value">23 months</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Gender:</span>
                    <span class="info-value">Female</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Race:</span>
                    <span class="info-value">Asian,Black or African American</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Language:</span>
                    <span class="info-value">Multilingual: English, Spanish, Chinese (Cantonese)</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Birth Date:</span>
                    <span class="info-value">09/07/2023</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Network Size:</span>
                    <span class="info-value">14 alters</span>
                </div>
            </div>
                </div>
  
                <div class="section sidebar-section" id="display-controls" style="display: none;">
                    <h3>Display Controls</h3>
                    
                    <div class="control-group">
                        <label>Layout Style:</label>
                        <select id="layoutStyle" onchange="updateVisualization()">
                            <option value="grouped">Grouped Context Boxes</option>
                            <option value="component">Component Membership</option>
                            <option value="traditional">Traditional Network</option>
                        </select>
                    </div>
  
                    <div class="control-group">
                        <label>Edge Visibility:</label>
                        <select id="edgeVisibility" onchange="updateEdgeVisibility()">
                            <option value="all">All ties (default)</option>
                            <option value="ego-only">Only ego→alter</option>
                            <option value="selected-only">Only selected alter ties</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <button class="btn" onclick="toggleSelectionView()" style="width: 100%; background: #42a5f5; color: white; border: none; padding: 0.5rem; border-radius: 6px; cursor: pointer; margin-bottom: 0.5rem;">
                            🔍 Toggle Selection View
                        </button>
                        <small style="color: #6c757d; font-size: 0.8rem;">Quick toggle between all edges and selected alter edges</small>
                    </div>
  
                    <div class="control-group">
                        <label>Search Alters:</label>
                        <input type="text" id="alterSearch" placeholder="Search by name..." oninput="searchAlters()" style="width: 100%; padding: 0.5rem; border: 1px solid #ced4da; border-radius: 6px;">
                    </div>
                    
  
  
                    <div class="control-group">
                        <label>Context Visibility:</label>
                        <div id="contextToggles"><div class="checkbox-group">
                    <input type="checkbox" id="context_home" checked="" onchange="toggleContext('home')">
                    <label for="context_home" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="width: 12px; height: 12px; background: #ffb3ba; border-radius: 3px; border: 1px solid #ccc;"></span>
                        Home
                    </label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="context_sibling" checked="" onchange="toggleContext('sibling')">
                    <label for="context_sibling" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="width: 12px; height: 12px; background: #ffdfba; border-radius: 3px; border: 1px solid #ccc;"></span>
                        Siblings
                    </label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="context_caregiver" checked="" onchange="toggleContext('caregiver')">
                    <label for="context_caregiver" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="width: 12px; height: 12px; background: #ffd6a5; border-radius: 3px; border: 1px solid #ccc;"></span>
                        Caregiver
                    </label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="context_daycare" checked="" onchange="toggleContext('daycare')">
                    <label for="context_daycare" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="width: 12px; height: 12px; background: #baffc9; border-radius: 3px; border: 1px solid #ccc;"></span>
                        Daycare
                    </label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="context_extended_family" checked="" onchange="toggleContext('extended_family')">
                    <label for="context_extended_family" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="width: 12px; height: 12px; background: #bae1ff; border-radius: 3px; border: 1px solid #ccc;"></span>
                        Extended Family
                    </label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="context_activity" checked="" onchange="toggleContext('activity')">
                    <label for="context_activity" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="width: 12px; height: 12px; background: #d4baff; border-radius: 3px; border: 1px solid #ccc;"></span>
                        Activities
                    </label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="context_anyoneelse" checked="" onchange="toggleContext('anyoneelse')">
                    <label for="context_anyoneelse" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="width: 12px; height: 12px; background: #888888; border-radius: 3px; border: 1px solid #ccc;"></span>
                        Anyone Else
                    </label>
                </div></div>
                    </div>
  
                    <div class="control-group">
                        <label>Color by:</label>
                        <select id="colorBy" onchange="updateVisualization()">
                            <option value="context">Context</option>
                            <option value="gender">Gender</option>
                            <option value="race">Race</option>
                            <option value="language">Language</option>
                            <option value="kin">Kin</option>
                        </select>
                    </div>
  
                    <div class="control-group">
                        <label>Node Size:</label>
                        <select id="nodeSizeBy" onchange="updateVisualization()">
                            <option value="default">Default</option>
                            <option value="weekly_hours">Weekly Hours</option>
                            <option value="closeness">Closeness Score</option>
                            <option value="closeness_intensity_z">Closeness Intensity Z-Score</option>
                        </select>
                    </div>
                </div>
  
                <div class="section sidebar-section" id="network-stats" style="display: none;">
                    <h3>Network Statistics</h3>
                    <div id="networkStatsContent">
                    <div style="font-size: 0.9rem; line-height: 1.5; display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                        <div title="Total number of alters in network"><strong>Size:</strong> 14</div>
                        <div title="Network density: edges / possible edges"><strong>Density:</strong> 0.290</div>
                        <div title="Number of connections between alters"><strong>Edges:</strong> 61</div>
                        <div title="Number of disconnected network components"><strong>Components:</strong> 3</div>
                        <div title="Network fragmentation measure"><strong>Component Ratio:</strong> 0.154</div>
                        <div title="Percentage of adult relationships"><strong>% Adult:</strong> 57.0%</div>
                        <div title="Percentage of kin relationships"><strong>% Kin:</strong> 50.0%</div>
                        <div title="Shannon entropy of racial diversity"><strong>Race Entropy:</strong> 2.47</div>
                        <div title="Racial homophily index"><strong>Racial EI:</strong> 0.14</div>
                        <div title="Shannon entropy of language diversity"><strong>Language Entropy:</strong> 1.66</div>
                        <div title="Language homophily index"><strong>Linguistic EI:</strong> -0.33</div>
                    </div>
                </div>
                </div>
                
                <div class="section sidebar-section" id="filters" style="display: none;">
                    <h3>Filters</h3>
                    
                    <div class="control-group">
                        <label>Gender:</label>
                        <div id="genderFilters"><div class="checkbox-group">
                    <input type="checkbox" id="gender_Female" checked="" onchange="toggleDemographicFilter('gender', 'Female')">
                    <label for="gender_Female" style="margin: 0; font-size: 0.85rem;">Female</label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="gender_Male" checked="" onchange="toggleDemographicFilter('gender', 'Male')">
                    <label for="gender_Male" style="margin: 0; font-size: 0.85rem;">Male</label>
                </div></div>
                    </div>
  
                    <div class="control-group">
                        <label>Race:</label>
                        <div id="raceFilters"><div class="checkbox-group">
                    <input type="checkbox" id="race_Hispanic/Latino" checked="" onchange="toggleDemographicFilter('race', 'Hispanic/Latino')">
                    <label for="race_Hispanic/Latino" style="margin: 0; font-size: 0.85rem;">Hispanic/Latino</label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="race_White" checked="" onchange="toggleDemographicFilter('race', 'White')">
                    <label for="race_White" style="margin: 0; font-size: 0.85rem;">White</label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="race_Black" checked="" onchange="toggleDemographicFilter('race', 'Black')">
                    <label for="race_Black" style="margin: 0; font-size: 0.85rem;">Black</label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="race_Asian" checked="" onchange="toggleDemographicFilter('race', 'Asian')">
                    <label for="race_Asian" style="margin: 0; font-size: 0.85rem;">Asian</label>
                </div></div>
                    </div>
  
                    <div class="control-group">
                        <label>Language:</label>
                        <div id="languageFilters"><div class="checkbox-group">
                    <input type="checkbox" id="language_English" checked="" onchange="toggleDemographicFilter('language', 'English')">
                    <label for="language_English" style="margin: 0; font-size: 0.85rem;">English</label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="language_German" checked="" onchange="toggleDemographicFilter('language', 'German')">
                    <label for="language_German" style="margin: 0; font-size: 0.85rem;">German</label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="language_Italian" checked="" onchange="toggleDemographicFilter('language', 'Italian')">
                    <label for="language_Italian" style="margin: 0; font-size: 0.85rem;">Italian</label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="language_Portuguese" checked="" onchange="toggleDemographicFilter('language', 'Portuguese')">
                    <label for="language_Portuguese" style="margin: 0; font-size: 0.85rem;">Portuguese</label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="language_Pre-verbal/Non-verbal" checked="" onchange="toggleDemographicFilter('language', 'Pre-verbal/Non-verbal')">
                    <label for="language_Pre-verbal/Non-verbal" style="margin: 0; font-size: 0.85rem;">Pre-verbal/Non-verbal</label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="language_Spanish" checked="" onchange="toggleDemographicFilter('language', 'Spanish')">
                    <label for="language_Spanish" style="margin: 0; font-size: 0.85rem;">Spanish</label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="language_Thai" checked="" onchange="toggleDemographicFilter('language', 'Thai')">
                    <label for="language_Thai" style="margin: 0; font-size: 0.85rem;">Thai</label>
                </div></div>
                    </div>
  
                    <div class="control-group">
                        <label>Kin:</label>
                        <div id="kinFilters"><div class="checkbox-group">
                    <input type="checkbox" id="kin_No" checked="" onchange="toggleDemographicFilter('kin', 'No')">
                    <label for="kin_No" style="margin: 0; font-size: 0.85rem;">No</label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="kin_Yes" checked="" onchange="toggleDemographicFilter('kin', 'Yes')">
                    <label for="kin_Yes" style="margin: 0; font-size: 0.85rem;">Yes</label>
                </div></div>
                    </div>
  
                    <div class="control-group">
                        <label>Mode of Contact:</label>
                        <div id="contactModeFilters"><div class="checkbox-group">
                    <input type="checkbox" id="contactMode_In-person only" checked="" onchange="toggleDemographicFilter('contactMode', 'In-person only')">
                    <label for="contactMode_In-person only" style="margin: 0; font-size: 0.85rem;">In-person only</label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="contactMode_Both virtually and in-person" checked="" onchange="toggleDemographicFilter('contactMode', 'Both virtually and in-person')">
                    <label for="contactMode_Both virtually and in-person" style="margin: 0; font-size: 0.85rem;">Both virtually and in-person</label>
                </div></div>
                    </div>
  
                    <div class="control-group">
                        <label>Contact Context:</label>
                        <div id="contactContextFilters"><div class="checkbox-group">
                    <input type="checkbox" id="contactContext_Activity 1" checked="" onchange="toggleDemographicFilter('contactContext', 'Activity 1')">
                    <label for="contactContext_Activity 1" style="margin: 0; font-size: 0.85rem;">Activity 1</label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="contactContext_Daycare/School, Activity 1" checked="" onchange="toggleDemographicFilter('contactContext', 'Daycare/School, Activity 1')">
                    <label for="contactContext_Daycare/School, Activity 1" style="margin: 0; font-size: 0.85rem;">Daycare/School, Activity 1</label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="contactContext_Activity 2" checked="" onchange="toggleDemographicFilter('contactContext', 'Activity 2')">
                    <label for="contactContext_Activity 2" style="margin: 0; font-size: 0.85rem;">Activity 2</label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="contactContext_Other" checked="" onchange="toggleDemographicFilter('contactContext', 'Other')">
                    <label for="contactContext_Other" style="margin: 0; font-size: 0.85rem;">Other</label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="contactContext_At home, Extended Family" checked="" onchange="toggleDemographicFilter('contactContext', 'At home, Extended Family')">
                    <label for="contactContext_At home, Extended Family" style="margin: 0; font-size: 0.85rem;">At home, Extended Family</label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="contactContext_At home, Extended Family, Activity 1, Activity 2" checked="" onchange="toggleDemographicFilter('contactContext', 'At home, Extended Family, Activity 1, Activity 2')">
                    <label for="contactContext_At home, Extended Family, Activity 1, Activity 2" style="margin: 0; font-size: 0.85rem;">At home, Extended Family, Activity 1, Activity 2</label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="contactContext_Daycare/School" checked="" onchange="toggleDemographicFilter('contactContext', 'Daycare/School')">
                    <label for="contactContext_Daycare/School" style="margin: 0; font-size: 0.85rem;">Daycare/School</label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="contactContext_At home, Extended Family, Activity 1" checked="" onchange="toggleDemographicFilter('contactContext', 'At home, Extended Family, Activity 1')">
                    <label for="contactContext_At home, Extended Family, Activity 1" style="margin: 0; font-size: 0.85rem;">At home, Extended Family, Activity 1</label>
                </div></div>
                    </div>
  
                    <div class="control-group">
                        <label>Age Category:</label>
                        <div id="ageCategoryFilters"><div class="checkbox-group">
                    <input type="checkbox" id="ageCategory_18 years old or older" checked="" onchange="toggleDemographicFilter('ageCategory', '18 years old or older')">
                    <label for="ageCategory_18 years old or older" style="margin: 0; font-size: 0.85rem;">18 years old or older</label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="ageCategory_2-5 years old" checked="" onchange="toggleDemographicFilter('ageCategory', '2-5 years old')">
                    <label for="ageCategory_2-5 years old" style="margin: 0; font-size: 0.85rem;">2-5 years old</label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="ageCategory_13-17 years old" checked="" onchange="toggleDemographicFilter('ageCategory', '13-17 years old')">
                    <label for="ageCategory_13-17 years old" style="margin: 0; font-size: 0.85rem;">13-17 years old</label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="ageCategory_Younger than 2 years old" checked="" onchange="toggleDemographicFilter('ageCategory', 'Younger than 2 years old')">
                    <label for="ageCategory_Younger than 2 years old" style="margin: 0; font-size: 0.85rem;">Younger than 2 years old</label>
                </div></div>
                    </div>
  
                    <div class="control-group">
                        <label>Min Weekly Hours: <span id="weeklyHoursValue">0</span></label>
                        <input type="range" id="minWeeklyHours" min="0" max="144" value="0" step="1" onchange="updateWeeklyHoursFilter()">
                    </div>
  
                    <div class="control-group">
                        <label>Min Closeness: <span id="closenessValue">0</span></label>
                        <input type="range" id="minCloseness" min="0" max="4" value="0" step="1" onchange="updateClosenessFilter()">
                    </div>
  
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="confidentialMode" onchange="toggleConfidentialMode()" style="margin-right: 8px;">
                            Confidential Mode
                        </label>
                        <div style="font-size: 0.8rem; color: #6c757d; margin-top: 4px;">
                            Replace names with anonymized labels
                        </div>
                    </div>
                </div>
  
                <div class="section sidebar-section" id="network-stats" style="display: none;">
                    <h3>Network Statistics</h3>
                    <div id="networkStatsContent">
                        <div style="color: #6c757d; font-style: italic; text-align: center; padding: 2rem;">
                            Select a child to view network statistics
                        </div>
                    </div>
                </div>
  
  
  

  
                <div class="section" id="alterDetailsSection" style="display: none;">
                    <h3>Alter Details</h3>
                    <div id="alterDetailsContent"></div>
                </div>
            </div>
        </div>
  
        <div class="main-content">
            <!-- Fixed details panel for alter/context details -->
            <div id="fixedDetailsPanel" class="fixed-details-panel" style="display: none;">
                <button class="close-panel" onclick="closeFixedDetails()">×</button>
                <h3 id="fixedDetailsTitle">Selected Alter</h3>
                <div id="fixedDetailsContent">
                <div class="info-row">
                    <span class="info-label">Name:</span>
                    <span class="info-value">Amy</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Role/Relationship:</span>
                    <span class="info-value">Teacher</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Gender:</span>
                    <span class="info-value">Female</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Age:</span>
                    <span class="info-value">18 years old or older</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Race:</span>
                    <span class="info-value">Asian,Black or African-American</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Language:</span>
                    <span class="info-value">English; Thai</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Kin:</span>
                    <span class="info-value">No</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Mode of Contact:</span>
                    <span class="info-value">In-person only</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Contact Context:</span>
                    <span class="info-value">Daycare/School</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Weekly Hours:</span>
                    <span class="info-value">36</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Hours % of week:</span>
                    <span class="info-value">21.4%</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Closeness Score:</span>
                    <span class="info-value">3</span>
                </div>
                
                    <div style="margin-top: 1rem; border-top: 1px solid #e9ecef; padding-top: 1rem;">
                        <div style="font-weight: 600; margin-bottom: 0.5rem; color: #495057;">Connected To (3):</div>
                        <div style="font-size: 0.85rem; line-height: 1.4;">
                            Molly, Willy, Tom
                        </div>
                    </div>
                
            </div>
            </div>
  
            <!-- Welcome Message -->
            <div id="welcomeMessage" style="display: block; text-align: center; padding: 3rem; color: #6c757d;">
                <h2 style="margin-bottom: 1rem; color: #495057;">Welcome to Network Visualization</h2>
                <p style="font-size: 1.1rem; margin-bottom: 2rem;">
                    Select a child from the dropdown and click "Visualize Network" to see their social network.
                </p>
                <div style="background: #f8f9fa; padding: 2rem; border-radius: 12px; max-width: 600px; margin: 0 auto;">
                    <h3 style="color: #42a5f5; margin-bottom: 1rem;">📊 What You'll See:</h3>
                    <ul style="text-align: left; line-height: 1.6;">
                        <li><strong>Social Network Map:</strong> Visual representation of the child's connections</li>
                        <li><strong>Context Groups:</strong> People organized by where they interact (home, daycare, activities)</li>
                        <li><strong>Interactive Elements:</strong> Click on people and boxes to explore details</li>
                        <li><strong>Customizable View:</strong> Change colors, sizes, and filters to explore different aspects</li>
                    </ul>
                </div>
            </div>
            
            <svg class="network-svg" id="networkSvg" style="display: none;"><g class="main-container"><g class="background-layer"><g class="context-box clickable" data-context-key="activity_1_Play date" style="cursor: move;"><rect x="726.5" y="80.85000000000002" width="215" height="157.5" rx="12" ry="12" style="fill: rgb(232, 197, 160); stroke: rgb(73, 80, 87); stroke-width: 2; stroke-dasharray: 5, 5; opacity: 0.8;"></rect><text x="834" y="100.85000000000002" style="text-anchor: middle; font-size: 14px; font-weight: bold; fill: rgb(44, 62, 80);">Activity 1: Play date</text><g class="alter-node" style="cursor: pointer;"><circle cx="790.25" cy="174.60000000000002" r="35" style="fill: white; stroke: rgb(232, 197, 160); stroke-width: 3;"></circle><text x="790.25" y="174.60000000000002" style="text-anchor: middle; dominant-baseline: middle; font-size: 13px; font-weight: 600; fill: rgb(44, 62, 80); pointer-events: auto; cursor: pointer; text-shadow: rgba(255, 255, 255, 0.8) 0px 0px 3px;">Jen</text></g><g class="alter-node" style="cursor: pointer;"><circle cx="877.75" cy="174.60000000000002" r="35" style="fill: white; stroke: rgb(232, 197, 160); stroke-width: 3;"></circle><text x="877.75" y="174.60000000000002" style="text-anchor: middle; dominant-baseline: middle; font-size: 13px; font-weight: 600; fill: rgb(44, 62, 80); pointer-events: auto; cursor: pointer; text-shadow: rgba(255, 255, 255, 0.8) 0px 0px 3px;">Gigi</text></g></g><g class="context-box clickable" data-context-key="activity_2_Gym" style="cursor: move;"><rect x="989.8265653138703" y="189.92343468612972" width="215" height="157.5" rx="12" ry="12" style="fill: rgb(168, 230, 207); stroke: rgb(73, 80, 87); stroke-width: 2; stroke-dasharray: 5, 5; opacity: 0.8;"></rect><text x="1097.3265653138703" y="209.92343468612972" style="text-anchor: middle; font-size: 14px; font-weight: bold; fill: rgb(44, 62, 80);">Activity 2: Gym</text><g class="alter-node" style="cursor: pointer;"><circle cx="1053.5765653138703" cy="283.6734346861297" r="35" style="fill: white; stroke: rgb(168, 230, 207); stroke-width: 3;"></circle><text x="1053.5765653138703" y="283.6734346861297" style="text-anchor: middle; dominant-baseline: middle; font-size: 13px; font-weight: 600; fill: rgb(44, 62, 80); pointer-events: auto; cursor: pointer; text-shadow: rgba(255, 255, 255, 0.8) 0px 0px 3px;">Orleo</text></g><g class="alter-node" style="cursor: pointer;"><circle cx="1141.0765653138703" cy="283.6734346861297" r="35" style="fill: white; stroke: rgb(168, 230, 207); stroke-width: 3;"></circle><text x="1141.0765653138703" y="283.6734346861297" style="text-anchor: middle; dominant-baseline: middle; font-size: 13px; font-weight: 600; fill: rgb(44, 62, 80); pointer-events: auto; cursor: pointer; text-shadow: rgba(255, 255, 255, 0.8) 0px 0px 3px;">Joey</text></g></g><g class="context-box" data-context-key="anyoneelse" style="cursor: move;"><rect x="1136.4" y="453.25" width="140" height="157.5" rx="12" ry="12" style="fill: rgb(136, 136, 136); stroke: none; stroke-width: 0; stroke-dasharray: none; opacity: 0.8;"></rect><text x="1206.4" y="473.25" style="text-anchor: middle; font-size: 14px; font-weight: bold; fill: rgb(44, 62, 80);">Anyone Else</text><g class="alter-node" style="cursor: pointer;"><circle cx="1200.15" cy="547" r="35" style="fill: white; stroke: rgb(136, 136, 136); stroke-width: 3;"></circle><text x="1200.15" y="547" style="text-anchor: middle; dominant-baseline: middle; font-size: 13px; font-weight: 600; fill: rgb(44, 62, 80); pointer-events: auto; cursor: pointer; text-shadow: rgba(255, 255, 255, 0.8) 0px 0px 3px;">Hookie</text></g></g><g class="context-box" data-context-key="caregiver" style="cursor: move;"><rect x="1027.3265653138703" y="716.5765653138703" width="140" height="157.5" rx="12" ry="12" style="fill: rgb(255, 214, 165); stroke: none; stroke-width: 0; stroke-dasharray: none; opacity: 0.8;"></rect><text x="1097.3265653138703" y="736.5765653138703" style="text-anchor: middle; font-size: 14px; font-weight: bold; fill: rgb(44, 62, 80);">Caregiver</text><g class="alter-node" style="cursor: pointer;"><circle cx="1091.0765653138703" cy="810.3265653138703" r="35" style="fill: white; stroke: rgb(255, 214, 165); stroke-width: 3;"></circle><text x="1091.0765653138703" y="810.3265653138703" style="text-anchor: middle; dominant-baseline: middle; font-size: 13px; font-weight: 600; fill: rgb(44, 62, 80); pointer-events: auto; cursor: pointer; text-shadow: rgba(255, 255, 255, 0.8) 0px 0px 3px;">Jolly</text></g></g><g class="context-box" data-context-key="extended_family" style="cursor: move;"><rect x="726.5" y="825.65" width="215" height="157.5" rx="12" ry="12" style="fill: rgb(186, 225, 255); stroke: none; stroke-width: 0; stroke-dasharray: none; opacity: 0.8;"></rect><text x="834" y="845.65" style="text-anchor: middle; font-size: 14px; font-weight: bold; fill: rgb(44, 62, 80);">Extended Family</text><g class="alter-node" style="cursor: pointer;"><circle cx="790.25" cy="919.4" r="35" style="fill: white; stroke: rgb(186, 225, 255); stroke-width: 3;"></circle><text x="790.25" y="919.4" style="text-anchor: middle; dominant-baseline: middle; font-size: 13px; font-weight: 600; fill: rgb(44, 62, 80); pointer-events: auto; cursor: pointer; text-shadow: rgba(255, 255, 255, 0.8) 0px 0px 3px;">Nana</text></g><g class="alter-node" style="cursor: pointer;"><circle cx="877.75" cy="919.4" r="35" style="fill: white; stroke: rgb(186, 225, 255); stroke-width: 3;"></circle><text x="877.75" y="919.4" style="text-anchor: middle; dominant-baseline: middle; font-size: 13px; font-weight: 600; fill: rgb(44, 62, 80); pointer-events: auto; cursor: pointer; text-shadow: rgba(255, 255, 255, 0.8) 0px 0px 3px;">Eugene</text></g></g><g class="context-box" data-context-key="home" style="cursor: move;"><rect x="463.17343468612967" y="716.5765653138703" width="215" height="157.5" rx="12" ry="12" style="fill: rgb(255, 179, 186); stroke: none; stroke-width: 0; stroke-dasharray: none; opacity: 0.8;"></rect><text x="570.6734346861297" y="736.5765653138703" style="text-anchor: middle; font-size: 14px; font-weight: bold; fill: rgb(44, 62, 80);">Home</text><g class="alter-node" style="cursor: pointer;"><circle cx="526.9234346861297" cy="810.3265653138703" r="35" style="fill: white; stroke: rgb(255, 179, 186); stroke-width: 3;"></circle><text x="526.9234346861297" y="810.3265653138703" style="text-anchor: middle; dominant-baseline: middle; font-size: 13px; font-weight: 600; fill: rgb(44, 62, 80); pointer-events: auto; cursor: pointer; text-shadow: rgba(255, 255, 255, 0.8) 0px 0px 3px;">Molly</text></g><g class="alter-node" style="cursor: pointer;"><circle cx="614.4234346861297" cy="810.3265653138703" r="35" style="fill: white; stroke: rgb(255, 179, 186); stroke-width: 3;"></circle><text x="614.4234346861297" y="810.3265653138703" style="text-anchor: middle; dominant-baseline: middle; font-size: 13px; font-weight: 600; fill: rgb(44, 62, 80); pointer-events: auto; cursor: pointer; text-shadow: rgba(255, 255, 255, 0.8) 0px 0px 3px;">Tom</text></g></g><g class="context-box clickable" data-context-key="daycare" style="cursor: move;"><rect x="354.1" y="453.25" width="215" height="157.5" rx="12" ry="12" style="fill: rgb(186, 255, 201); stroke: rgb(73, 80, 87); stroke-width: 2; stroke-dasharray: 5, 5; opacity: 0.8;"></rect><text x="461.6" y="473.25" style="text-anchor: middle; font-size: 14px; font-weight: bold; fill: rgb(44, 62, 80);">Daycare</text><g class="alter-node" style="cursor: pointer;"><circle cx="417.85" cy="547" r="35" style="fill: white; stroke: rgb(186, 255, 201); stroke-width: 3;"></circle><text x="417.85" y="547" style="text-anchor: middle; dominant-baseline: middle; font-size: 13px; font-weight: 600; fill: rgb(44, 62, 80); pointer-events: auto; cursor: pointer; text-shadow: rgba(255, 255, 255, 0.8) 0px 0px 3px;">Willy</text></g><g class="alter-node" style="cursor: pointer;"><circle cx="505.35" cy="547" r="35" style="fill: white; stroke: rgb(186, 255, 201); stroke-width: 3;"></circle><text x="505.35" y="547" style="text-anchor: middle; dominant-baseline: middle; font-size: 13px; font-weight: 600; fill: rgb(44, 62, 80); pointer-events: auto; cursor: pointer; text-shadow: rgba(255, 255, 255, 0.8) 0px 0px 3px;">Amy</text></g></g><g class="context-box" data-context-key="sibling" style="cursor: move;"><rect x="463.17343468612967" y="189.92343468612972" width="215" height="157.5" rx="12" ry="12" style="fill: rgb(255, 223, 186); stroke: none; stroke-width: 0; stroke-dasharray: none; opacity: 0.8;"></rect><text x="570.6734346861297" y="209.92343468612972" style="text-anchor: middle; font-size: 14px; font-weight: bold; fill: rgb(44, 62, 80);">Siblings</text><g class="alter-node" style="cursor: pointer;"><circle cx="526.9234346861297" cy="283.6734346861297" r="35" style="fill: white; stroke: rgb(255, 223, 186); stroke-width: 3;"></circle><text x="526.9234346861297" y="283.6734346861297" style="text-anchor: middle; dominant-baseline: middle; font-size: 13px; font-weight: 600; fill: rgb(44, 62, 80); pointer-events: auto; cursor: pointer; text-shadow: rgba(255, 255, 255, 0.8) 0px 0px 3px;">Bentley</text></g><g class="alter-node" style="cursor: pointer;"><circle cx="614.4234346861297" cy="283.6734346861297" r="35" style="fill: white; stroke: rgb(255, 223, 186); stroke-width: 3;"></circle><text x="614.4234346861297" y="283.6734346861297" style="text-anchor: middle; dominant-baseline: middle; font-size: 13px; font-weight: 600; fill: rgb(44, 62, 80); pointer-events: auto; cursor: pointer; text-shadow: rgba(255, 255, 255, 0.8) 0px 0px 3px;">Georgie</text></g></g></g><g class="edges-layer"><line class="alter-edge" x1="756.0664572970824" y1="188.75928699750835" x2="561.1069773890473" y2="269.5141476886214" data-source="act1adult1_jen" data-target="sibling1_bentley" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="758.8084836863819" y1="194.10464180395252" x2="645.8649509997477" y2="264.16879288217723" data-source="act1adult1_jen" data-target="sibling2_georgie" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="776.0907130024917" y1="208.78354270291763" x2="541.0827216836379" y2="776.1430226109527" data-source="act1adult1_jen" data-target="liveathome1_molly" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="780.3869776291882" y1="210.26119445157252" x2="624.2864570569415" y2="774.6653708622978" data-source="act1adult1_jen" data-target="liveathome2_tom" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><path class="alter-edge" d="M 827.25 174.60000000000002 Q 834 177.3 840.75 174.60000000000002" data-source="act1adult1_jen" data-target="act1kid1_gigi" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; fill: none; pointer-events: auto;"></path><line class="alter-edge" x1="842.4182257146209" y1="185.58479521188363" x2="562.2552089715088" y2="272.6886394742461" data-source="act1kid1_gigi" data-target="sibling1_bentley" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="843.5664572970824" y1="188.75928699750835" x2="648.6069773890473" y2="269.5141476886214" data-source="act1kid1_gigi" data-target="sibling2_georgie" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="859.872979019634" y1="206.99463105002985" x2="544.8004556664956" y2="777.9319342638405" data-source="act1kid1_gigi" data-target="liveathome1_molly" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="863.5907130024917" y1="208.78354270291763" x2="628.5827216836379" y2="776.1430226109527" data-source="act1kid1_gigi" data-target="liveathome2_tom" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1027.413614409968" y1="309.83638559003197" x2="553.0863855900319" y2="784.1636144099681" data-source="act2adult1_orleo" data-target="liveathome1_molly" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1029.880970006235" y1="312.09030930345466" x2="638.1190299937651" y2="781.9096906965455" data-source="act2adult1_orleo" data-target="liveathome2_tom" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><path class="alter-edge" d="M 1090.5765653138703 283.6734346861297 Q 1097.3265653138703 286.3734346861297 1104.0765653138703 283.6734346861297" data-source="act2adult1_orleo" data-target="act2kid1_joey" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; fill: none; pointer-events: auto;"></path><line class="alter-edge" x1="1112.989408389483" y1="307.7589410313334" x2="555.0105916105169" y2="786.2410589686666" data-source="act2kid1_joey" data-target="liveathome1_molly" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1114.913614409968" y1="309.83638559003197" x2="640.5863855900319" y2="784.1636144099681" data-source="act2kid1_joey" data-target="liveathome2_tom" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1165.6921083821087" y1="560.4778969149363" x2="561.3813263040211" y2="796.848668398934" data-source="anyoneelse1_hookie" data-target="liveathome1_molly" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1166.4035078987972" y1="562.171495340389" x2="648.1699267873327" y2="795.1550699734813" data-source="anyoneelse1_hookie" data-target="liveathome2_tom" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1165.6921083821087" y1="533.5221030850637" x2="561.3813263040211" y2="297.151331601066" data-source="anyoneelse1_hookie" data-target="sibling1_bentley" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1166.4035078987972" y1="531.828504659611" x2="648.1699267873327" y2="298.84493002651874" data-source="anyoneelse1_hookie" data-target="sibling2_georgie" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1054.0765653138703" y1="810.3265653138703" x2="563.9234346861297" y2="810.3265653138703" data-source="caregiver1_jolly" data-target="liveathome1_molly" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1054.0765653138703" y1="810.3265653138703" x2="651.4234346861297" y2="810.3265653138703" data-source="caregiver1_jolly" data-target="liveathome2_tom" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1064.0301560526884" y1="785.0779664205327" x2="553.9698439473116" y2="308.92203357946744" data-source="caregiver1_jolly" data-target="sibling1_bentley" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1066.2482631802177" y1="782.8938218644801" x2="639.2517368197822" y2="311.10617813552" data-source="caregiver1_jolly" data-target="sibling2_georgie" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="776.0907130024917" y1="885.2164572970823" x2="541.0827216836379" y2="317.8569773890473" data-source="extendedfamily1_nana" data-target="sibling1_bentley" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="780.3869776291882" y1="883.7388055484274" x2="624.2864570569415" y2="319.3346291377022" data-source="extendedfamily1_nana" data-target="sibling2_georgie" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="756.0664572970824" y1="905.2407130024917" x2="561.1069773890473" y2="824.4858523113786" data-source="extendedfamily1_nana" data-target="liveathome1_molly" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="758.8084836863819" y1="899.8953581960475" x2="645.8649509997477" y2="829.8312071178228" data-source="extendedfamily1_nana" data-target="liveathome2_tom" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="859.872979019634" y1="887.0053689499701" x2="544.8004556664956" y2="316.06806573615955" data-source="extendedfamily2_eugene" data-target="sibling1_bentley" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="863.5907130024917" y1="885.2164572970823" x2="628.5827216836379" y2="317.8569773890473" data-source="extendedfamily2_eugene" data-target="sibling2_georgie" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="842.4182257146208" y1="908.4152047881164" x2="562.2552089715089" y2="821.3113605257539" data-source="extendedfamily2_eugene" data-target="liveathome1_molly" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="843.5664572970824" y1="905.2407130024917" x2="648.6069773890473" y2="824.4858523113786" data-source="extendedfamily2_eugene" data-target="liveathome2_tom" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><path class="alter-edge" d="M 827.25 919.4 Q 834 922.1 840.75 919.4" data-source="extendedfamily1_nana" data-target="extendedfamily2_eugene" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; fill: none; pointer-events: auto;"></path><line class="alter-edge" x1="526.9234346861297" y1="773.3265653138703" x2="526.9234346861297" y2="320.6734346861297" data-source="liveathome1_molly" data-target="sibling1_bentley" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="532.9876174883756" y1="773.8268983709934" x2="608.3592518838838" y2="320.1731016290067" data-source="liveathome1_molly" data-target="sibling2_georgie" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><path class="alter-edge" d="M 563.9234346861297 810.3265653138703 Q 570.6734346861297 813.0265653138704 577.4234346861297 810.3265653138703" data-source="liveathome1_molly" data-target="liveathome2_tom" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; fill: none; pointer-events: auto;"></path><line class="alter-edge" x1="523.9022746576261" y1="773.4501149412793" x2="508.3711600285036" y2="583.8764503725911" data-source="liveathome1_molly" data-target="teacher1_amy" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="512.7641476886214" y1="776.1430226109527" x2="432.00928699750835" y2="581.1835427029176" data-source="liveathome1_molly" data-target="schoolkid1_willy" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="608.3592518838838" y1="773.8268983709934" x2="532.9876174883756" y2="320.1731016290067" data-source="liveathome2_tom" data-target="sibling1_bentley" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="614.4234346861297" y1="773.3265653138703" x2="614.4234346861297" y2="320.6734346861297" data-source="liveathome2_tom" data-target="sibling2_georgie" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><path class="alter-edge" d="M 454.85 547 Q 461.6 549.7 468.35 547" data-source="schoolkid1_willy" data-target="teacher1_amy" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; fill: none; pointer-events: auto;"></path><path class="alter-edge" d="M 563.9234346861297 283.6734346861297 Q 570.6734346861297 286.3734346861297 577.4234346861297 283.6734346861297" data-source="sibling1_bentley" data-target="sibling2_georgie" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; fill: none; pointer-events: auto;"></path><line class="alter-edge" x1="600.2641476886214" y1="776.1430226109527" x2="519.5092869975083" y2="581.1835427029176" data-source="liveathome2_tom" data-target="teacher1_amy" style="stroke: rgb(74, 85, 104); stroke-width: 1.5; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line></g><g class="nodes-layer"><g class="ego-node" style="cursor: pointer;"><rect x="804" y="502" width="60" height="60" rx="9" ry="9" style="fill: rgb(20, 184, 166); stroke: white; stroke-width: 3;"></rect><text x="834" y="532" style="text-anchor: middle; dominant-baseline: middle; font-size: 12px; font-weight: bold; fill: white; pointer-events: none;">Orca</text></g></g></g></svg>
  
            <div class="legend" id="legend" style="display: none;">
                <div class="legend-section" id="colorLegendSection">
                    <h4 id="colorLegendTitle">Color by: Context</h4>
                    <div id="colorLegendItems"><div class="legend-item">
                <div style="width: 16px; height: 16px; background: #14b8a6; border-radius: 3px; border: 1px solid rgba(0,0,0,0.2);"></div>
                <span>Child (Ego)</span>
            </div><div class="legend-item">
                        <div class="legend-color" style="background: #ffb3ba;"></div>
                        <span>Home</span>
                    </div><div class="legend-item">
                        <div class="legend-color" style="background: #ffdfba;"></div>
                        <span>Siblings</span>
                    </div><div class="legend-item">
                        <div class="legend-color" style="background: #ffd6a5;"></div>
                        <span>Caregiver</span>
                    </div><div class="legend-item">
                        <div class="legend-color" style="background: #baffc9;"></div>
                        <span>Daycare</span>
                    </div><div class="legend-item">
                        <div class="legend-color" style="background: #bae1ff;"></div>
                        <span>Extended Family</span>
                    </div><div class="legend-item">
                        <div class="legend-color" style="background: #888888;"></div>
                        <span>Anyone Else</span>
                    </div><div class="legend-item">
                        <div class="legend-color" style="background: #e8c5a0;"></div>
                        <span>Activity 1: Play date</span>
                    </div><div class="legend-item">
                        <div class="legend-color" style="background: #a8e6cf;"></div>
                        <span>Activity 2: Gym</span>
                    </div></div>
                </div>
                <div class="legend-section" id="sizeLegendSection" style="display: none;">
                    <h4 id="sizeLegendTitle">Node Size: Weekly Hours</h4>
                    <div id="sizeLegendItems">
                        <div class="size-legend-item">
                            <div class="size-circle" style="width: 25px; height: 25px;"></div>
                            <span>≤4h</span>
                        </div>
                    
                        <div class="size-legend-item">
                            <div class="size-circle" style="width: 30px; height: 30px;"></div>
                            <span>4.1-5h</span>
                        </div>
                    
                        <div class="size-legend-item">
                            <div class="size-circle" style="width: 35px; height: 35px;"></div>
                            <span>5.1-30h</span>
                        </div>
                    
                        <div class="size-legend-item">
                            <div class="size-circle" style="width: 40px; height: 40px;"></div>
                            <span>30.1-60h</span>
                        </div>
                    
                        <div class="size-legend-item">
                            <div class="size-circle" style="width: 45px; height: 45px;"></div>
                            <span>&gt;60h</span>
                        </div>
                    </div>
                </div>
                <div class="legend-section" id="edgeLegendSection" style="display: none;">
                    <h4>Edge Key</h4>
                    <div class="legend-item">
                        <div style="width: 20px; height: 2px; background: #9CA3AF; border-radius: 1px;"></div>
                        <span style="font-size: 0.8rem;">Default</span>
                    </div>
                    <div class="legend-item">
                        <div style="width: 20px; height: 2px; background: #F97316; border-radius: 1px;"></div>
                        <span style="font-size: 0.8rem;">Selected</span>
                    </div>
                </div>
            </div>
  
            <!-- Information Panels -->
            <div id="contextPanel" class="info-panel" style="display: none;">
                <button class="close-panel" onclick="closePanel('contextPanel')">×</button>
                <h3 id="contextTitle">Context Information</h3>
                <div id="contextContent"></div>
            </div>
  
            <div id="alterPanel" class="info-panel" style="display: none;">
                <button class="close-panel" onclick="closePanel('alterPanel')">×</button>
                <h3>Alter Information</h3>
                <div id="alterContent"></div>
            </div>
  
            <!-- Ego panel removed - child information now in sidebar -->
  
            <!-- Unified details panel for both alters and contexts -->
            <div id="unifiedDetailsCard" class="floating-card" style="display: none;">
                <button class="close-panel" onclick="closeUnifiedDetails()">×</button>
                <h3 id="unifiedDetailsTitle">Details</h3>
                <div id="unifiedDetailsContent"></div>
            </div>
  
            <!-- Resizable moveable details panel for selected alter -->
            <div id="resizableDetailsPanel" class="resizable-details-panel" style="display: none;">
                <div class="panel-header">
                    <h3>Selected Alter</h3>
                    <button class="close-btn" onclick="closeResizableDetails()">×</button>
                </div>
                <div class="panel-content" id="resizableDetailsContent">
                    <!-- Content will be populated by JavaScript -->
                </div>
                <!-- Resize handles -->
                <div class="resize-handle resize-handle-n"></div>
                <div class="resize-handle resize-handle-s"></div>
                <div class="resize-handle resize-handle-e"></div>
                <div class="resize-handle resize-handle-w"></div>
                <div class="resize-handle resize-handle-ne"></div>
                <div class="resize-handle resize-handle-nw"></div>
                <div class="resize-handle resize-handle-se"></div>
                <div class="resize-handle resize-handle-sw"></div>
            </div>
        </div>
    </div>
  
    <!-- Sample Formats Modal -->
    <div id="sampleModal" class="help-overlay" style="display: none;" onclick="closeSampleModal()">
        <div class="help-panel" onclick="event.stopPropagation()">
            <button class="close-panel" onclick="closeSampleModal()">×</button>
            <h3>File Format Requirements</h3>
            <div style="line-height: 1.6;">
                <p style="margin-bottom: 1.5rem; color: #666; font-size: 0.95rem;">
                    Your CSV files need specific column names to work properly. Here's what each file should contain:
                </p>

                <h4 style="margin: 1rem 0 0.5rem 0; color: #42a5f5;">📋 long_df.csv - People in the Network</h4>
                <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                    <strong>Required columns:</strong>
                    <ul style="margin: 0.5rem 0 0 0 1.5rem;">
                        <li><code>ChildID</code> - Unique identifier for each child</li>
                        <li><code>node_type</code> - Type of person (e.g., "sibling", "caregiver", "friend")</li>
                        <li><code>node_name</code> - Name of the person</li>
                        <li><code>node_mapping_code</code> - Unique code for each person</li>
                    </ul>
                    <strong>Optional columns:</strong>
                    <ul style="margin: 0.5rem 0 0 0 1.5rem;">
                        <li><code>node_gender</code>, <code>node_race</code>, <code>node_language</code></li>
                        <li><code>node_kin</code> - Family relationship</li>
                        <li><code>node_weekly_hour_summarized</code> - Hours spent together</li>
                        <li><code>node_closeness_score</code> - How close the relationship is</li>
                    </ul>
                </div>

                <h4 style="margin: 1rem 0 0.5rem 0; color: #42a5f5;">📊 network_wide.csv - Network Summary</h4>
                <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                    <strong>Required columns:</strong>
                    <ul style="margin: 0.5rem 0 0 0 1.5rem;">
                        <li><code>ChildID</code> - Unique identifier for each child</li>
                        <li><code>child_name</code> - Name of the child</li>
                        <li><code>network_size</code> - Total number of people in the network</li>
                        <li><code>network_density</code> - How connected the network is</li>
                        <li><code>edges_number</code> - Total number of connections</li>
                    </ul>
                </div>

                <h4 style="margin: 1rem 0 0.5rem 0; color: #42a5f5;">🎯 activity_long.csv - Activities & Participation</h4>
                <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                    <strong>Required columns:</strong>
                    <ul style="margin: 0.5rem 0 0 0 1.5rem;">
                        <li><code>ChildID</code> - Unique identifier for each child</li>
                        <li><code>activity_id</code> - Unique identifier for each activity</li>
                        <li><code>activity_name</code> - Name of the activity (e.g., "Soccer", "Daycare")</li>
                    </ul>
                </div>

                <div style="background: #e3f2fd; padding: 1rem; border-radius: 8px; margin-top: 1.5rem; border-left: 4px solid #42a5f5;">
                    <strong>💡 Tip:</strong> Make sure your column names match exactly (including capitalization). 
                    The dashboard will automatically detect and use any optional columns you include.
                </div>
            </div>
        </div>
    </div>
  
    <div class="help-overlay" id="helpOverlay" onclick="hideHelp()">
        <div class="help-panel" onclick="event.stopPropagation()">
            <button class="close-panel" onclick="hideHelp()">×</button>
            <h3>What This Dashboard Does</h3>
            <div style="line-height: 1.6;">
                <p style="margin-bottom: 1.5rem; color: #666; font-size: 0.95rem;">
                    <strong>SNQ Network Plotting Dashboard</strong> creates visual maps of children's social networks. 
                    It shows who children interact with, how often, and in what contexts (home, daycare, activities, etc.).
                </p>

                <h4 style="margin: 1rem 0 0.5rem 0; color: #42a5f5;">🎯 What You'll See</h4>
                <ul style="margin-left: 1.5rem;">
                    <li><strong>Social Network Map:</strong> Visual representation of a child's social connections</li>
                    <li><strong>Context Groups:</strong> People organized by where they interact (home, daycare, activities)</li>
                    <li><strong>Connection Lines:</strong> Shows relationships between the child and others</li>
                    <li><strong>Demographic Info:</strong> Age, gender, race, language of people in the network</li>
                </ul>

                <h4 style="margin: 1rem 0 0.5rem 0; color: #42a5f5;">📁 What Files You Need</h4>
                <ul style="margin-left: 1.5rem;">
                    <li><strong>long_df.csv:</strong> List of people in the network with their details</li>
                    <li><strong>network_wide.csv:</strong> Overall network statistics for each child</li>
                    <li><strong>activity_long.csv:</strong> Information about activities and who participates</li>
                </ul>

                <h4 style="margin: 1rem 0 0.5rem 0; color: #42a5f5;">🚀 Quick Start</h4>
                <ol style="margin-left: 1.5rem;">
                    <li>Upload your 3 CSV files above</li>
                    <li>Click "Process & Validate" to check your data</li>
                    <li>Select a child from the dropdown menu</li>
                    <li>Click "Visualize Network" to see their social network</li>
                </ol>

                <h4 style="margin: 1rem 0 0.5rem 0; color: #42a5f5;">💡 Pro Tips</h4>
                <ul style="margin-left: 1.5rem;">
                    <li><strong>Click on people:</strong> Highlights them and shows their connections</li>
                    <li><strong>Click on boxes:</strong> See details about different groups (home, daycare, etc.)</li>
                    <li><strong>Use filters:</strong> Hide people by age, gender, or other characteristics</li>
                    <li><strong>Change colors:</strong> Color people by different characteristics (gender, race, etc.)</li>
                </ul>
            </div>
        </div>
    </div>
  
    <!-- Tooltip disabled - no black box popups -->
    <div class="tooltip" id="tooltip" style="display: none !important; opacity: 0 !important; visibility: hidden !important;">Amy</div>
  
    <script>
        // Global state
        const state = {
            data: {
                longDf: null,
                networkWide: null,
                activityLong: null,
                activityIndex: {}
            },
            current: {
                child: null,
                childData: null,
                alterData: null,
                alterEdges: []
            },
            ui: {
                page: 'welcome', // 'welcome', 'validate', 'mode', 'child', 'dataset'
                layoutStyle: 'grouped',
                nodeSizeBy: 'default',
                colorBy: 'context',
                visibleContexts: new Set(),
                showAlterEdges: true,
                edgeVisibility: 'all', // 'all', 'ego-only', 'selected-only'
                selectedAlter: null,
                selectedContext: null,
                detailsType: null, // 'alter' or 'context'
                filters: {
                    gender: new Set(),
                    race: new Set(),
                    language: new Set(),
                    kin: new Set(),
                    contactMode: new Set(),
                    contactContext: new Set(),
                    ageCategory: new Set(),
                    minWeeklyHours: 0,
                    minCloseness: 0
                },
                searchTerm: '',
                confidentialMode: false
            },
            validation: {
                passed: false,
                results: {
                    longDf: { passed: false, errors: [] },
                    networkWide: { passed: false, errors: [] },
                    activityLong: { passed: false, errors: [] }
                }
            }
        };
  
        // Context configuration
        const CONTEXTS = {
            'home': { 
                color: '#ffb3ba', 
                label: 'Home',
                keywords: ['liveathome', 'home']
            },
            'sibling': { 
                color: '#ffdfba', 
                label: 'Siblings',
                keywords: ['sibling']
            },
            'caregiver': { 
                color: '#ffd6a5', 
                label: 'Caregiver',
                keywords: ['caregiver', 'nanny', 'babysitter']
            },
            'daycare': { 
                color: '#baffc9', 
                label: 'Daycare',
                keywords: ['daycare', 'teacher', 'schoolkid']
            },
            'extended_family': { 
                color: '#bae1ff', 
                label: 'Extended Family',
                keywords: ['extended_family', 'extendedfamily']
            },
            'activity': { 
                color: '#d4baff', 
                label: 'Activities',
                keywords: ['activity', 'act']
            },
            'anyoneelse': { 
                color: '#888888', 
                label: 'Anyone Else',
                keywords: ['other', 'anyoneelse']
            }
        };
  
        // Distinct activity colors for Activity 1-7
        const ACTIVITY_COLORS = [
            '#e8c5a0',  // Activity 1 - warm beige
            '#a8e6cf',  // Activity 2 - mint green
            '#ffd3a5',  // Activity 3 - peach
            '#ffa3b5',  // Activity 4 - coral pink
            '#b5ead7',  // Activity 5 - seafoam
            '#c2c5e8',  // Activity 6 - lavender
            '#ffaaa5'   // Activity 7 - salmon
        ];
  
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });
  
        function initializeApp() {
            setupFileHandlers();
            initializeContextToggles();
            initializePageRouting();
            initializeSidebarResize();
            
            // Restore saved sidebar width
            const savedWidth = localStorage.getItem('sidebarWidth');
            if (savedWidth) {
                const sidebar = document.getElementById('sidebar');
                if (sidebar) {
                    sidebar.style.width = savedWidth + 'px';
                }
            }
        }
  
        // Page routing functions
        function initializePageRouting() {
            // Check for existing data on page load
            if (state.data.longDf && state.data.networkWide && state.data.activityLong) {
                if (state.validation.passed) {
                    if (state.current.child) {
                        showPage('child');
                    } else {
                        showPage('mode');
                    }
                } else {
                    showPage('validate');
                }
            } else {
                showPage('welcome');
            }
        }
  
        function showPage(pageName) {
            // Hide all pages
            document.querySelectorAll('.page').forEach(page => {
                page.classList.add('hidden');
            });
            
            // Show target page
            const targetPage = document.getElementById(pageName + 'Page');
            if (targetPage) {
                targetPage.classList.remove('hidden');
                state.ui.page = pageName;
            }
            
            // Update page-specific initialization
            if (pageName === 'welcome') {
                updateUploadButtons();
            } else if (pageName === 'child') {
                // Simple approach: just try to render whatever is currently selected
                setTimeout(() => {
                    const select = document.getElementById('childSelect');
                    if (select && select.value) {
                        // If there's already a child selected, render it
                        console.log('Page load - rendering existing selection:', select.value);
                        visualizeNetwork();
                    } else if (select && select.options.length > 1) {
                        // Auto-select first child and render
                        console.log('Page load - auto-selecting first child');
                        select.selectedIndex = 1;
                        visualizeNetwork();
                    }
                }, 100);
            } else if (pageName === 'wholeData') {
                // Initialize whole data exploration
                setTimeout(() => {
                    initializeWholeDataExploration();
                }, 100);
            }
        }
  
        function goToWelcome() {
            // Reset validation state but preserve uploaded files
            state.validation.passed = false;
            showPage('welcome');
        }
  
        function goToValidate() {
            showPage('validate');
        }
  
        function goToMode() {
            showPage('mode');
        }
  
        function startChildExploration() {
            showPage('child');
            // Set default tab to Child Selection
            setTimeout(() => {
                showSidebarSection('child-selection');
                const select = document.getElementById('childSelect');
                if (select && select.value) {
                    // If there's already a child selected, render it
                    visualizeNetwork();
                } else if (select && select.options.length > 1) {
                    // If no child selected, select the first one and render
                    select.selectedIndex = 1;
                    updateChildSelection();
                }
            }, 200);
        }

        // Sidebar resize functionality
        function initializeSidebarResize() {
            const sidebar = document.getElementById('sidebar');
            const resizeHandle = document.getElementById('sidebarResizeHandle');
            let isResizing = false;
            let startX, startWidth;

            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = parseInt(getComputedStyle(sidebar).width, 10);
                document.body.style.cursor = 'col-resize';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const deltaX = e.clientX - startX;
                const newWidth = Math.max(280, Math.min(600, startWidth + deltaX));
                
                sidebar.style.width = newWidth + 'px';
                
                // Update visualization width if it exists
                updateVisualizationWidth(newWidth);
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    
                    // Save the width to localStorage
                    const currentWidth = parseInt(getComputedStyle(sidebar).width, 10);
                    localStorage.setItem('sidebarWidth', currentWidth);
                }
            });
        }

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const toggleBtn = document.getElementById('sidebarToggleBtn');
            
            if (sidebar.classList.contains('collapsed')) {
                // Expand sidebar
                sidebar.classList.remove('collapsed');
                toggleBtn.innerHTML = '◀';
                toggleBtn.title = 'Collapse Sidebar';
                
                // Restore saved width or use default
                const savedWidth = localStorage.getItem('sidebarWidth') || 340;
                sidebar.style.width = savedWidth + 'px';
            } else {
                // Collapse sidebar
                sidebar.classList.add('collapsed');
                toggleBtn.innerHTML = '▶';
                toggleBtn.title = 'Expand Sidebar';
                
                // Save current width before collapsing
                const currentWidth = parseInt(getComputedStyle(sidebar).width, 10);
                localStorage.setItem('sidebarWidth', currentWidth);
            }
            
            // Update visualization width
            updateVisualizationWidth();
        }

        function updateVisualizationWidth(sidebarWidth) {
            // Update the width calculation in createGroupedVisualization
            if (state.current.alterData && state.current.alterData.length > 0) {
                // Trigger a redraw with new width
                setTimeout(() => {
                    if (state.ui.page === 'child') {
                        createGroupedVisualization();
                    }
                }, 100);
            }
        }

        function toggleWholeDataSidebar() {
            const sidebar = document.getElementById('wholeDataSidebar');
            const toggleBtn = document.getElementById('wholeDataSidebarToggleBtn');
            
            if (sidebar.classList.contains('collapsed')) {
                // Expand sidebar
                sidebar.classList.remove('collapsed');
                toggleBtn.innerHTML = '◀';
                toggleBtn.title = 'Collapse Sidebar';
                
                // Restore saved width or use default
                const savedWidth = localStorage.getItem('wholeDataSidebarWidth') || 340;
                sidebar.style.width = savedWidth + 'px';
            } else {
                // Collapse sidebar
                sidebar.classList.add('collapsed');
                toggleBtn.innerHTML = '▶';
                toggleBtn.title = 'Expand Sidebar';
                
                // Save current width before collapsing
                const currentWidth = parseInt(getComputedStyle(sidebar).width, 10);
                localStorage.setItem('wholeDataSidebarWidth', currentWidth);
            }
        }
        
        function startWholeDataExploration() {
            showPage('wholeData');
            // Initialize the whole data exploration
            setTimeout(() => {
                initializeWholeDataExploration();
            }, 200);
        }
  
        function goToDataset() {
            showPage('dataset');
        }
  
        function showSampleFormats() {
            document.getElementById('sampleModal').style.display = 'block';
        }
  
        function closeSampleModal() {
            document.getElementById('sampleModal').style.display = 'none';
        }
  
        function setupFileHandlers() {
            document.getElementById('longDfFile').addEventListener('change', (e) => handleFileUpload(e, 'longDf'));
            document.getElementById('networkWideFile').addEventListener('change', (e) => handleFileUpload(e, 'networkWide'));
            document.getElementById('activityLongFile').addEventListener('change', (e) => handleFileUpload(e, 'activityLong'));
        }
  
        function updateUploadButtons() {
            const processBtn = document.getElementById('processBtn');
            const filesReady = state.data.longDf && state.data.networkWide && state.data.activityLong;
            
            if (processBtn) {
                processBtn.disabled = !filesReady;
            }
            
            // Update upload zone statuses
            updateUploadZoneStatus('longDf', state.data.longDf);
            updateUploadZoneStatus('networkWide', state.data.networkWide);
            updateUploadZoneStatus('activityLong', state.data.activityLong);
        }
  
        function updateUploadZoneStatus(fileType, data) {
            const zone = document.querySelector(`[onclick*="${fileType}File"]`);
            const status = document.getElementById(fileType + 'Status');
            
            if (!zone || !status) return;
            
            zone.classList.remove('loaded', 'error');
            
            if (data) {
                zone.classList.add('loaded');
                status.innerHTML = `✓ Loaded ${data.length} rows`;
                status.className = 'upload-status success';
            } else {
                status.innerHTML = '';
                status.className = 'upload-status';
            }
        }
  
        function initializeContextToggles() {
            const container = document.getElementById('contextToggles');
            if (!container) return;
            container.innerHTML = '';
            state.ui.visibleContexts = new Set();
            
            Object.entries(CONTEXTS).forEach(([key, config]) => {
                state.ui.visibleContexts.add(key);
                
                const div = document.createElement('div');
                div.className = 'checkbox-group';
                div.innerHTML = `
                    <input type="checkbox" id="context_${key}" checked onchange="toggleContext('${key}')">
                    <label for="context_${key}" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="width: 12px; height: 12px; background: ${config.color}; border-radius: 3px; border: 1px solid #ccc;"></span>
                        ${config.label}
                    </label>
                `;
                container.appendChild(div);
            });
        }
  
        function toggleContext(contextKey) {
            const checkbox = document.getElementById(`context_${contextKey}`);
            if (checkbox.checked) {
                state.ui.visibleContexts.add(contextKey);
            } else {
                state.ui.visibleContexts.delete(contextKey);
            }
            updateVisualization();
        }
  
        function updateEdgeVisibility() {
            const select = document.getElementById('edgeVisibility');
            state.ui.edgeVisibility = select.value;
            
            // Force redraw of edges with new visibility setting
            if (state.current.alterEdges && state.current.alterEdges.length > 0) {
                redrawAlterEdges();
            }
            
            updateVisualization();
        }
        
        function toggleSelectionView() {
            // Toggle between "all" and "selected-only" views
            if (state.ui.edgeVisibility === 'all') {
                state.ui.edgeVisibility = 'selected-only';
                document.getElementById('edgeVisibility').value = 'selected-only';
            } else {
                state.ui.edgeVisibility = 'all';
                document.getElementById('edgeVisibility').value = 'all';
            }
            updateVisualization();
        }
  
        function searchAlters() {
            const searchTerm = document.getElementById('alterSearch').value.toLowerCase().trim();
            state.ui.searchTerm = searchTerm;
            
            // Remove previous search highlighting
            d3.selectAll('.alter-node').classed('search-match', false);
            
            if (searchTerm) {
                // Find matching alters
                const matches = [];
                d3.selectAll('.alter-node').each(function(d) {
                    if (d && d.name.toLowerCase().includes(searchTerm)) {
                        d3.select(this).classed('search-match', true);
                        matches.push(d);
                    }
                });
                
                // Center on first match if found
                if (matches.length > 0) {
                    centerOnAlter(matches[0]);
                }
            }
        }
  
        function centerOnAlter(alter) {
            // Scroll/pan to bring alter into view (basic implementation)
            if (alter.x && alter.y) {
                const container = document.querySelector('.main-content');
                // Simple centering - could be enhanced with smooth animation
                container.scrollTo({
                    left: alter.x - container.clientWidth / 2 + 380, // Account for sidebar
                    top: alter.y - container.clientHeight / 2,
                    behavior: 'smooth'
                });
            }
        }
  
        function updateWeeklyHoursFilter() {
            const slider = document.getElementById('minWeeklyHours');
            const value = parseFloat(slider.value);
            document.getElementById('weeklyHoursValue').textContent = value;
            state.ui.filters.minWeeklyHours = value;
            updateVisualization();
        }
  
        function updateClosenessFilter() {
            const slider = document.getElementById('minCloseness');
            const value = parseFloat(slider.value);
            document.getElementById('closenessValue').textContent = value.toFixed(0);
            state.ui.filters.minCloseness = value;
            updateVisualization();
        }
  
        function toggleDemographicFilter(type, value) {
            const filterSet = state.ui.filters[type];
            if (filterSet.has(value)) {
                filterSet.delete(value);
            } else {
                filterSet.add(value);
            }
            updateVisualization();
        }
  
        function toggleContactModeFilter(value) {
            toggleDemographicFilter('contactMode', value);
        }
  
        function toggleContactContextFilter(value) {
            toggleDemographicFilter('contactContext', value);
        }
  
        function toggleAgeCategoryFilter(value) {
            toggleDemographicFilter('ageCategory', value);
        }
  
        function toggleConfidentialMode() {
            state.ui.confidentialMode = document.getElementById('confidentialMode').checked;
            updateVisualization();
        }
  
        // Helper function to get anonymized text for nodes
        function getAnonymizedText(nodeData, isEgo = false) {
            if (!state.ui.confidentialMode) {
                return isEgo ? nodeData.name : nodeData.name;
            }
  
            if (isEgo) {
                return 'Child';
            }
  
            // Check for siblings - use node_type + node_index
            const nodeType = nodeData.data?.node_type || nodeData.node_type || '';
            const nodeIndex = nodeData.data?.node_index || nodeData.node_index || '';
            
            if (nodeType.toLowerCase() === 'sibling') {
                return `Sibling${nodeIndex || '1'}`;
            }
            
            // Check for activity kids - ONLY those with node_type like "Act1Kid", "Act2Kid"
            const name = nodeData.name || '';
            const context = nodeData.context || '';
            
            // Only label as activity kid if node_type specifically contains "Kid" (e.g., "Act1Kid", "Act2Kid")
            const isActivityKid = nodeType.toLowerCase().includes('kid') && 
                                 (nodeType.toLowerCase().includes('act') || nodeType.toLowerCase().includes('activity'));
            
            if (isActivityKid) {
                // Extract activity number from node_type (e.g., "Act1Kid" -> "1")
                let actNum = '1'; // default
                
                // Try to extract from node_type first (most reliable for kids)
                const typeMatch = nodeType.match(/act(\d+)kid/i);
                if (typeMatch) {
                    actNum = typeMatch[1];
                } else {
                    // Fallback: try to extract from context
                    const contextMatch = context.match(/activity_(\d+)/i);
                    if (contextMatch) {
                        actNum = contextMatch[1];
                    }
                }
                
                return `Act${actNum}Kid${nodeIndex || '1'}`;
            }
            
            if (nodeType.toLowerCase().includes('school') || nodeData.name?.toLowerCase().includes('schoolkid')) {
                return `SchoolKid${nodeIndex || '1'}`;
            }
  
            // For named alters, use relationship from the correct data path
            const hasName = nodeData.name && !nodeData.name.toLowerCase().includes('kid');
            
            if (hasName) {
                // Use relationship for named alters - check both possible data paths
                const relationship = nodeData.data?.node_relationship || nodeData.node_relationship;
                return relationship || 'Unknown Relationship';
            } else {
                // Generate anonymized label for other unnamed alters
                return generateAnonymizedLabel(nodeData);
            }
        }
  
        // Helper function to generate anonymized labels for unnamed alters
        function generateAnonymizedLabel(nodeData) {
            const name = nodeData.name || '';
            const alterType = nodeData.node_type || '';
            
            // Create a unique identifier based on node properties
            const uniqueId = nodeData.node_id || nodeData.name || Math.random().toString(36).substr(2, 5);
            
            if (name.toLowerCase().includes('schoolkid') || alterType.toLowerCase().includes('school')) {
                return `SchoolKid${uniqueId.slice(-1)}`;
            } else if (name.toLowerCase().includes('activitykid') || name.toLowerCase().includes('activity')) {
                // Try to extract activity number from name
                const actMatch = name.match(/activity(\d+)/i);
                const actNum = actMatch ? actMatch[1] : '1';
                const kidNum = uniqueId.slice(-1);
                return `Act${actNum}Kid${kidNum}`;
            } else if (alterType.toLowerCase().includes('activity')) {
                return `ActKid${uniqueId.slice(-1)}`;
            }
            
            // Default fallback
            return `Alter${uniqueId.slice(-1)}`;
        }
  
        function handleFileUpload(event, fileType) {
            const file = event.target.files[0];
            if (!file) return;
  
            const zone = document.querySelector(`[onclick*="${fileType}File"]`);
            const statusElement = document.getElementById(fileType + 'Status');
            
            // Reset zone state
            zone.classList.remove('loaded', 'error');
            statusElement.innerHTML = 'Processing...';
            statusElement.className = 'upload-status';
  
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                complete: function(results) {
                    if (results.errors.length > 0) {
                        zone.classList.add('error');
                        statusElement.innerHTML = `✕ Error: ${results.errors[0].message}`;
                        statusElement.className = 'upload-status error';
                        state.data[fileType] = null;
                        updateUploadButtons();
                        return;
                    }
  
                    if (!results.data || results.data.length === 0) {
                        zone.classList.add('error');
                        statusElement.innerHTML = '✕ No data found in file';
                        statusElement.className = 'upload-status error';
                        state.data[fileType] = null;
                        updateUploadButtons();
                        return;
                    }
  
                    // Clean and normalize data
                    const cleanedData = results.data.filter(row => row && Object.keys(row).some(key => row[key]));
                    
                    // Normalize ChildID variants
                    cleanedData.forEach(row => {
                        if (row.childID && !row.ChildID) row.ChildID = row.childID;
                        if (row.child_id && !row.ChildID) row.ChildID = row.child_id;
                    });
                    
                    // Convert childcare values to integers for proper display
                    if (fileType === 'networkWide') {
                        cleanedData.forEach(row => {
                            if (row.childcare_start_age) {
                                row.childcare_start_age = Math.round(parseFloat(row.childcare_start_age));
                            }
                            if (row.childcare_size) {
                                row.childcare_size = Math.round(parseFloat(row.childcare_size));
                            }
                        });
                    }
  
                    state.data[fileType] = cleanedData;
                    zone.classList.add('loaded');
                    statusElement.innerHTML = `✓ Loaded ${cleanedData.length} rows`;
                    statusElement.className = 'upload-status success';
                    
                    updateUploadButtons();
                },
                error: function(error) {
                    zone.classList.add('error');
                    statusElement.innerHTML = `✕ Error: ${error.message}`;
                    statusElement.className = 'upload-status error';
                    state.data[fileType] = null;
                    updateUploadButtons();
                }
            });
        }
  
  
  
        function processData() {
            // Build activity index for fast lookup
            buildActivityIndex();
            
            // Run comprehensive validation
            runValidation();
            
            // Transition to validation page
            showPage('validate');
        }
  
        function runValidation() {
            // Reset validation state
            state.validation.results = {
                longDf: { passed: false, errors: [] },
                networkWide: { passed: false, errors: [] },
                activityLong: { passed: false, errors: [] }
            };
  
            // Validate each file
            validateLongDf();
            validateNetworkWide();
            validateActivityLong();
  
            // Check ChildID intersection
            validateChildIdIntersection();
  
            // Update overall validation status
            const allPassed = Object.values(state.validation.results).every(result => result.passed);
            state.validation.passed = allPassed;
  
            // Populate child selector if validation passed
            if (allPassed) {
            populateChildSelector();
            }
  
            // Render validation results
            renderValidationResults();
        }
  
        function validateLongDf() {
            const data = state.data.longDf;
            const result = state.validation.results.longDf;
            
            if (!data || data.length === 0) {
                result.errors.push('No data loaded');
                return;
            }
  
            const requiredColumns = ['ChildID', 'node_type', 'node_name', 'node_mapping_code'];
            const availableColumns = Object.keys(data[0] || {});
            const missingColumns = requiredColumns.filter(col => !availableColumns.includes(col));
  
            if (missingColumns.length > 0) {
                result.errors.push(`Missing required columns: ${missingColumns.join(', ')}`);
            }
  
            // Check for duplicates
            const duplicates = new Map();
            data.forEach(row => {
                const key = `${row.ChildID}_${row.node_mapping_code}`;
                duplicates.set(key, (duplicates.get(key) || 0) + 1);
            });
            
            const duplicateKeys = Array.from(duplicates.entries()).filter(([key, count]) => count > 1);
            if (duplicateKeys.length > 0) {
                result.errors.push(`Duplicate node_mapping_code entries found for same ChildID: ${duplicateKeys.length} cases`);
            }
  
            result.passed = result.errors.length === 0;
        }
  
        function validateNetworkWide() {
            const data = state.data.networkWide;
            const result = state.validation.results.networkWide;
            
            if (!data || data.length === 0) {
                result.errors.push('No data loaded');
                return;
            }
  
            const requiredColumns = [
                'ChildID', 'child_name', 'network_size', 'network_density', 'edges_number',
                'component_count', 'component_ratio', 'prop_adult_relationship', 'prop_kin_relationship',
                'race_entropy', 'racial_ei_index', 'language_entropy', 'linguistic_ei_index'
            ];
            
            const availableColumns = Object.keys(data[0] || {});
            const missingColumns = requiredColumns.filter(col => !availableColumns.includes(col));
  
            if (missingColumns.length > 0) {
                result.errors.push(`Missing required columns: ${missingColumns.join(', ')}`);
            }
  
            result.passed = result.errors.length === 0;
        }
  
        function validateActivityLong() {
            const data = state.data.activityLong;
            const result = state.validation.results.activityLong;
            
            if (!data || data.length === 0) {
                result.errors.push('No data loaded');
                return;
            }
  
            const requiredColumns = ['ChildID', 'activity_id', 'activity_name'];
            const availableColumns = Object.keys(data[0] || {});
            const missingColumns = requiredColumns.filter(col => !availableColumns.includes(col));
  
            if (missingColumns.length > 0) {
                result.errors.push(`Missing required columns: ${missingColumns.join(', ')}`);
            }
  
            result.passed = result.errors.length === 0;
        }
  
        function validateChildIdIntersection() {
            const longDfChildIds = new Set((state.data.longDf || []).map(row => row.ChildID).filter(Boolean));
            const networkWideChildIds = new Set((state.data.networkWide || []).map(row => row.ChildID).filter(Boolean));
            const activityLongChildIds = new Set((state.data.activityLong || []).map(row => row.ChildID).filter(Boolean));
  
            const intersection = new Set([...longDfChildIds].filter(id => 
                networkWideChildIds.has(id) && activityLongChildIds.has(id)
            ));
  
            if (intersection.size === 0) {
                state.validation.results.longDf.errors.push('No common ChildIDs found across all three files');
                state.validation.results.networkWide.errors.push('No common ChildIDs found across all three files');
                state.validation.results.activityLong.errors.push('No common ChildIDs found across all three files');
            }
        }
  
        function renderValidationResults() {
            const statusDiv = document.getElementById('validationStatus');
            const resultsDiv = document.getElementById('validationResults');
            const continueBtn = document.getElementById('continueBtn');
  
            // Update overall status
            if (state.validation.passed) {
                statusDiv.innerHTML = '✅ All checks passed<br><span style="color: #155724;">Your data look good.</span>';
                statusDiv.className = 'validation-status pass';
                continueBtn.disabled = false;
            } else {
                statusDiv.innerHTML = '❌ Issues found<br><span style="color: #721c24;">Please review the errors below.</span>';
                statusDiv.className = 'validation-status fail';
                continueBtn.disabled = true;
            }
  
            // Render file-specific results
            const files = [
                { key: 'longDf', name: 'long_df.csv' },
                { key: 'networkWide', name: 'network_wide.csv' },
                { key: 'activityLong', name: 'activity_long.csv' }
            ];
  
            resultsDiv.innerHTML = files.map(file => {
                const result = state.validation.results[file.key];
                const statusIcon = result.passed ? '✓' : '✗';
                const statusClass = result.passed ? 'pass' : 'fail';
                
                const checks = [
                    { label: 'Required columns present', passed: result.errors.length === 0 || !result.errors.some(e => e.includes('Missing required columns')) },
                    { label: 'Data integrity', passed: result.errors.length === 0 || !result.errors.some(e => e.includes('Duplicate') || e.includes('common ChildIDs')) }
                ];
  
                const checksHtml = checks.map(check => `
                    <div class="validation-check">
                        <div class="check-icon ${check.passed ? 'pass' : 'fail'}">
                            ${check.passed ? '✓' : '✗'}
                        </div>
                        <span>${check.label}</span>
                    </div>
                `).join('');
  
                const errorsHtml = result.errors.length > 0 ? 
                    `<div style="margin-top: 0.5rem; color: #721c24; font-size: 0.85rem;">
                        ${result.errors.map(error => `• ${error}`).join('<br>')}
                    </div>` : '';
  
                return `
                    <div class="validation-file">
                        <h4>
                            <div class="check-icon ${statusClass}">${statusIcon}</div>
                            ${file.name}
                        </h4>
                        ${checksHtml}
                        ${errorsHtml}
                    </div>
                `;
            }).join('');
        }
  
        function validateNetworkWideSchema() {
            if (!state.data.networkWide || state.data.networkWide.length === 0) {
                console.warn('No network_wide data loaded for schema validation');
                return;
            }
            
            const sampleRow = state.data.networkWide[0];
            const requiredFields = ['component_count', 'component_ratio'];
            const availableFields = Object.keys(sampleRow);
            
            console.log('Network_wide schema check:');
            console.log('Available fields:', availableFields);
            console.log('Looking for:', requiredFields);
            
            // Case-insensitive and trimmed field matching
            const normalizedAvailable = availableFields.map(f => f.trim().toLowerCase());
            const missingFields = requiredFields.filter(field => {
                const normalizedField = field.trim().toLowerCase();
                const found = normalizedAvailable.includes(normalizedField);
                console.log(`Looking for '${field}' (normalized: '${normalizedField}'):`, found ? 'FOUND' : 'MISSING');
                return !found;
            });
            
            // Remove any existing error badge first
            const statsSection = document.getElementById('networkStats');
            const header = statsSection?.querySelector('h3');
            const existingBadge = header?.querySelector('.schema-error');
            if (existingBadge) {
                existingBadge.remove();
            }
            
            if (missingFields.length > 0) {
                console.error('Missing columns in network_wide:', missingFields);
                console.error('Available columns:', availableFields);
                
                // Add red badge to Network Summary
                if (header) {
                    const badge = document.createElement('span');
                    badge.className = 'schema-error';
                    badge.style.cssText = `
                        background: #dc3545;
                        color: white;
                        font-size: 0.7rem;
                        padding: 2px 6px;
                        border-radius: 3px;
                        margin-left: 8px;
                        font-weight: 500;
                    `;
                    badge.textContent = 'component fields not found';
                    badge.title = `Missing: ${missingFields.join(', ')}\nAvailable: ${availableFields.slice(0, 10).join(', ')}...`;
                    header.appendChild(badge);
                }
            } else {
                console.log('✓ All required component fields found');
            }
        }
  
        function buildActivityIndex() {
            state.data.activityIndex = {};
            
            if (state.data.activityLong) {
                state.data.activityLong.forEach(activity => {
                    const childId = activity.ChildID || activity.childID;
                    if (!state.data.activityIndex[childId]) {
                        state.data.activityIndex[childId] = {};
                    }
                    const activityId = String(activity.activity_id || '').trim();
                    if (activityId) {
                        state.data.activityIndex[childId][activityId] = activity;
                    }
                });
            }
        }
  
        function populateChildSelector() {
            if (!state.data.networkWide) return;
            
            const childIds = [...new Set(state.data.networkWide.map(d => d.ChildID))].filter(id => id).sort();
            
            const select = document.getElementById('childSelect');
            select.innerHTML = '<option value="">Choose a child...</option>';
            
            childIds.forEach(id => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = id;
                select.appendChild(option);
            });
        }
  
        function updateChildSelection() {
            const select = document.getElementById('childSelect');
            const visualizeBtn = document.getElementById('visualizeBtn');
            
            if (visualizeBtn) {
                visualizeBtn.disabled = !select.value;
            }
            
            // Auto-update: when a new child is chosen, re-render immediately
            if (select.value && state.ui.page === 'child') {
                console.log('Auto-rendering for child:', select.value);
                visualizeNetwork();
            }
        }
  
        function visualizeNetwork() {
            const childId = document.getElementById('childSelect').value;
            console.log('visualizeNetwork called with child:', childId);
            if (!childId) {
                console.log('No child selected');
                return;
            }
            
            // Set current data
            state.current.child = childId;
            state.current.childData = state.data.networkWide ? state.data.networkWide.find(d => d.ChildID === childId) : null;
            state.current.alterData = state.data.longDf ? state.data.longDf.filter(d => d.ChildID === childId) : [];
            state.current.alterEdges = parseAlterEdges(state.current.alterData);
            
            // Update sidebar child info whenever child data changes
            updateSidebarChildInfo();
            
            console.log('Data loaded:', {
                childId,
                childData: !!state.current.childData,
                alterCount: state.current.alterData.length,
                edgeCount: state.current.alterEdges.length
            });
            
            // Reset quantiles for new dataset
            state.current.hourQuantiles = null;
            state.current.closenessQuantiles = null;
            
            // Initialize filters
            try {
                initializeDemographicFilters();
            } catch (error) {
                console.warn('Error initializing demographic filters:', error);
            }
            
            // Show network stats
            try {
            updateNetworkStats();
            } catch (error) {
                console.warn('Error updating network stats:', error);
            }
            
            // Ensure we create the visualization immediately
            if (state.current.alterData.length > 0) {
                console.log('Creating visualization...');
                try {
            createGroupedVisualization();
                } catch (error) {
                    console.error('Error creating visualization:', error);
                }
            } else {
                console.log('No alter data found for child:', childId);
                // Clear the visualization area if no data
                const svg = d3.select('#networkSvg');
                if (!svg.empty()) {
                    svg.selectAll('*').remove();
                }
            }
        }
  
        // Language set for validation
        const LANGUAGE_SET = new Set([
            "english", "german", "spanish", "portuguese", "italian", "thai", 
            "pre-verbal/non-verbal", "preverbal/nonverbal", "preverbal", "nonverbal", 
            "pre-verbal", "non-verbal"
        ]);
  
        function normLangList(s) {
            const raw = String(s || '').toLowerCase();
            const tokens = raw.split(/[;,/|]+/).map(x => x.trim()).filter(Boolean);
            if (tokens.length === 0) return ['unknown'];
            return tokens.map(t => {
                if (t.startsWith('pre')) return 'pre-verbal/non-verbal';
                if (!LANGUAGE_SET.has(t)) return t; // keep but won't be in whitelist; still match via intersection if whitelist empty
                return t;
            });
        }
  
        function normalizeLanguage(rawLanguage) {
            if (!rawLanguage) return ['Unknown']; // Don't return empty array
            
            // Remove "Multilingual:" prefix if present
            let cleanLanguage = rawLanguage;
            if (typeof cleanLanguage === 'string') {
                cleanLanguage = cleanLanguage.replace(/^multilingual:\s*/i, '');
            }
            
            const languageMap = {
                'english': 'English',
                'german': 'German', 
                'spanish': 'Spanish',
                'portuguese': 'Portuguese',
                'italian': 'Italian',
                'thai': 'Thai',
                'chinese': 'Chinese',
                'cantonese': 'Chinese (Cantonese)',
                'mandarin': 'Chinese (Mandarin)',
                'french': 'French',
                'japanese': 'Japanese',
                'korean': 'Korean',
                'arabic': 'Arabic',
                'hindi': 'Hindi',
                'russian': 'Russian',
                'dutch': 'Dutch',
                'swedish': 'Swedish',
                'norwegian': 'Norwegian',
                'danish': 'Danish',
                'finnish': 'Finnish',
                'polish': 'Polish',
                'czech': 'Czech',
                'hungarian': 'Hungarian',
                'greek': 'Greek',
                'turkish': 'Turkish',
                'hebrew': 'Hebrew',
                'persian': 'Persian',
                'vietnamese': 'Vietnamese',
                'filipino': 'Filipino',
                'indonesian': 'Indonesian',
                'malay': 'Malay',
                'preverbal': 'Pre-verbal/Non-verbal',
                'pre-verbal': 'Pre-verbal/Non-verbal',
                'nonverbal': 'Pre-verbal/Non-verbal',
                'non-verbal': 'Pre-verbal/Non-verbal',
                'non verbal': 'Pre-verbal/Non-verbal',
                'unknown': 'Unknown'
            };
            
            const normalized = cleanLanguage.split(/[,;/|]+/)
                .map(lang => lang.trim().toLowerCase())
                .map(lang => languageMap[lang] || lang)
                .filter(lang => lang && lang !== '');
            
            // Return up to first 5 languages for pie charts, but ensure at least 'Unknown' if empty
            const result = normalized.slice(0, 5);
            return result.length > 0 ? result : ['Unknown'];
        }
  
        function canonContext(raw) {
            const t = String(raw || '').toLowerCase().trim();
  
            // Activities: "act1", "act1kid", "act2", "act2kid", ...
            const m = t.match(/^act\s*([0-9]+)/) || t.match(/^act([0-9]+)kid$/);
            if (m) return `activity_${m[1]}`;
  
            if (t === 'liveathome' || t === 'home') return 'home';
            if (t === 'sibling' || t === 'siblings') return 'sibling';
  
            // *** Caregiver must be its own context (not daycare) ***
            if (t === 'caregiver' || t === 'nanny' || t === 'babysitter') return 'caregiver';
  
            // Daycare should include only teachers/schoolkids
            if (t === 'teacher' || t === 'schoolkid' || t === 'daycare') return 'daycare';
  
            // Extended family appears with a space in CSV
            if (t.includes('extended') && t.includes('family')) return 'extended_family';
  
            if (t === 'anyoneelse' || t === 'other' || t === 'others') return 'anyoneelse';
  
            // Fallback
            return 'anyoneelse';
        }
  
        function createLanguagePieWedges(languages, nodeId, radius) {
            if (!languages || languages.length === 0) return '';
            
            const languagePalette = {
                'English': '#1f77b4',
                'German': '#ff7f0e', 
                'Spanish': '#2ca02c',
                'Portuguese': '#d62728',
                'Italian': '#9467bd',
                'Thai': '#8c564b',
                'Pre-verbal/Non-verbal': '#7f7f7f',
                'Unknown': '#cccccc'
            };
            
            const anglePerLang = (2 * Math.PI) / languages.length;
            let paths = '';
            
            languages.forEach((lang, i) => {
                const startAngle = i * anglePerLang;
                const endAngle = (i + 1) * anglePerLang;
                
                const x1 = radius * Math.cos(startAngle);
                const y1 = radius * Math.sin(startAngle);
                const x2 = radius * Math.cos(endAngle);
                const y2 = radius * Math.sin(endAngle);
                
                const largeArcFlag = anglePerLang > Math.PI ? 1 : 0;
                
                const pathData = `M 0 0 L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2} Z`;
                const color = languagePalette[lang] || '#cccccc';
                
                paths += `<path d="${pathData}" fill="${color}" stroke="none"/>`;
            });
            
            return paths;
        }
  
        function initializeDemographicFilters() {
            if (!state.current.alterData) return;
            
            // Extract unique values for each demographic (with canonicalization and Unknown handling)
            const genders = [...new Set(state.current.alterData.map(d => d.node_gender || 'Unknown'))];
            
            // Debug race values
            console.log('Raw race values:', state.current.alterData.map(d => d.node_race));
            const races = [...new Set(state.current.alterData.map(d => canonRace(d.node_race)))];
            console.log('Canonicalized races:', races);
            
            const kinValues = [...new Set(state.current.alterData.map(d => canonKin(d.node_kin)))];
            
            // Mode of contact filter
            const contactModes = [...new Set(state.current.alterData.map(d => d.node_mode_of_contact || 'Unknown'))];
            
            // Contact context filter - parse and clean the complex text
            const contactContexts = [...new Set(state.current.alterData.map(d => parseContactContext(d.node_context)))];
            
            // Age category filter
            const ageCategories = [...new Set(state.current.alterData.map(d => d.node_age_categorized || 'Unknown'))];
            
            // Extract actual languages from current child's data
            const languagesInData = [...new Set(state.current.alterData.map(d => {
                const langString = d.node_language || 'Unknown';
                return normalizeLanguage(langString);
            }).flat())];
            const languages = languagesInData.sort();
            
            populateFilterCheckboxes('genderFilters', genders, 'gender');
            populateFilterCheckboxes('raceFilters', races, 'race');
            populateFilterCheckboxes('languageFilters', languages, 'language');
            populateFilterCheckboxes('kinFilters', kinValues, 'kin');
            populateFilterCheckboxes('contactModeFilters', contactModes, 'contactMode');
            populateFilterCheckboxes('contactContextFilters', contactContexts, 'contactContext');
            populateFilterCheckboxes('ageCategoryFilters', ageCategories, 'ageCategory');
            
            // Update weekly hours slider range based on current child's data
            updateWeeklyHoursSliderRange();
        }
  
        function updateWeeklyHoursSliderRange() {
            if (!state.current.alterData || state.current.alterData.length === 0) return;
            
            // Extract weekly hours from current child's alter data
            const weeklyHours = state.current.alterData.map(d => {
                const hours = parseFloat(d.node_weekly_hour_summarized || d.node_weekly_hour || 0);
                return isNaN(hours) ? 0 : hours;
            }).filter(h => h > 0); // Only include non-zero values
            
            if (weeklyHours.length === 0) return;
            
            const minHours = Math.min(...weeklyHours);
            const maxHours = Math.max(...weeklyHours);
            
            // Update the slider attributes
            const slider = document.getElementById('minWeeklyHours');
            if (slider) {
                slider.min = 0; // Always start from 0
                slider.max = Math.ceil(maxHours); // Round up to nearest integer
                slider.value = 0; // Reset to 0
                
                // Update the display value
                document.getElementById('weeklyHoursValue').textContent = '0';
                
                // Reset the filter state
                state.ui.filters.minWeeklyHours = 0;
                
                console.log(`Updated weekly hours slider: min=0, max=${Math.ceil(maxHours)}, range in data: ${minHours}-${maxHours}`);
            }
        }
  
        function populateFilterCheckboxes(containerId, values, filterType) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            values.forEach(value => {
                const div = document.createElement('div');
                div.className = 'checkbox-group';
                div.innerHTML = `
                    <input type="checkbox" id="${filterType}_${value}" checked onchange="toggleDemographicFilter('${filterType}', '${value}')">
                    <label for="${filterType}_${value}" style="margin: 0; font-size: 0.85rem;">${value}</label>
                `;
                container.appendChild(div);
                
                // Initialize filter set
                state.ui.filters[filterType].add(value);
            });
        }
  
        function formatMetric(value, decimals = 2, isPercent = false) {
            if (value === null || value === undefined || value === '' || isNaN(value)) {
                console.log(`formatMetric: returning '?' for value:`, value);
                return '?';
            }
            const num = parseFloat(value);
            if (isNaN(num)) {
                console.log(`formatMetric: parseFloat returned NaN for value:`, value);
                return '?';
            }
            if (isPercent) {
                return (num * 100).toFixed(1) + '%';
            }
            return num.toFixed(decimals);
        }
        
        // Helper function to clean childcare type text
        function formatChildcareType(childcareType) {
            if (!childcareType || childcareType === '') {
                return 'N/A';
            }
            
            // Split by commas and clean each type
            const types = childcareType.split(',').map(type => {
                // Remove content in parentheses and clean up
                let cleanType = type.trim();
                
                // Remove text in parentheses
                cleanType = cleanType.replace(/\([^)]*\)/g, '').trim();
                
                // Clean up common patterns
                cleanType = cleanType.replace(/^Day care center.*$/i, 'Day care center');
                cleanType = cleanType.replace(/^Licensed family day care.*$/i, 'Licensed family day care');
                cleanType = cleanType.replace(/^Family child care.*$/i, 'Family child care');
                cleanType = cleanType.replace(/^In-home care.*$/i, 'In-home care');
                cleanType = cleanType.replace(/^Nanny.*$/i, 'Nanny');
                cleanType = cleanType.replace(/^Au pair.*$/i, 'Au pair');
                cleanType = cleanType.replace(/^Relative.*$/i, 'Relative');
                cleanType = cleanType.replace(/^Other.*$/i, 'Other');
                
                return cleanType;
            }).filter(type => type.length > 0);
            
            return types.join(', ');
        }
  
        function updateNetworkStats() {
            // Only update sidebar stats content
            const sidebarStatsContent = document.getElementById('networkStatsContent');
            
            if (!state.current.childData) {
                // Show no data message in sidebar
                if (sidebarStatsContent) {
                    sidebarStatsContent.innerHTML = '<div style="color: #6c757d; font-style: italic; text-align: center; padding: 2rem;">Select a child to view network statistics</div>';
                }
                return;
            }
  
            const childData = state.current.childData;
            
            // Use network_wide data directly, not computed from filtered view
            const networkSize = childData.network_size || '?';
            const networkDensity = formatMetric(childData.network_density, 3);
            const edgesNumber = childData.edges_number || '?';
            // Robust field access for components (handle case/spacing variations)
            const componentCountRaw = childData.component_count || childData.Component_Count || childData['component count'];
            const componentRatioRaw = childData.component_ratio || childData.Component_Ratio || childData['component ratio'];
            
            console.log('Component debugging:');
            console.log('component_count value:', componentCountRaw);
            console.log('component_ratio value:', componentRatioRaw);
            console.log('Child data keys:', Object.keys(childData));
            
            const componentCount = componentCountRaw || '?';
            const componentRatio = formatMetric(componentRatioRaw, 3);
            const propAdult = formatMetric(childData.prop_adult_relationship, 1, true);
            const propKin = formatMetric(childData.prop_kin_relationship, 1, true);
            const raceEntropy = formatMetric(childData.race_entropy, 2);
            const racialEI = formatMetric(childData.racial_ei_index, 2);
            const languageEntropy = formatMetric(childData.language_entropy, 2);
            const linguisticEI = formatMetric(childData.linguistic_ei_index, 2);
            
            // Update the sidebar stats section
            if (sidebarStatsContent) {
                sidebarStatsContent.innerHTML = `
                    <div style="font-size: 0.9rem; line-height: 1.5; display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                        <div title="Total number of alters in network"><strong>Size:</strong> ${networkSize}</div>
                        <div title="Network density: edges / possible edges"><strong>Density:</strong> ${networkDensity}</div>
                        <div title="Number of connections between alters"><strong>Edges:</strong> ${edgesNumber}</div>
                        <div title="Number of disconnected network components"><strong>Components:</strong> ${componentCount}</div>
                        <div title="Network fragmentation measure"><strong>Component Ratio:</strong> ${componentRatio}</div>
                        <div title="Percentage of adult relationships"><strong>% Adult:</strong> ${propAdult}</div>
                        <div title="Percentage of kin relationships"><strong>% Kin:</strong> ${propKin}</div>
                        <div title="Shannon entropy of racial diversity"><strong>Race Entropy:</strong> ${raceEntropy}</div>
                        <div title="Racial homophily index"><strong>Racial EI:</strong> ${racialEI}</div>
                        <div title="Shannon entropy of language diversity"><strong>Language Entropy:</strong> ${languageEntropy}</div>
                        <div title="Language homophily index"><strong>Linguistic EI:</strong> ${linguisticEI}</div>
                    </div>
                `;
            }
        }
  
        function updateVisualization() {
            state.ui.layoutStyle = document.getElementById('layoutStyle').value;
            state.ui.nodeSizeBy = document.getElementById('nodeSizeBy').value;
            state.ui.colorBy = document.getElementById('colorBy').value;
            
            if (state.current.child) {
                createGroupedVisualization();
            }
        }
        
        function takeScreenshot() {
            // Check if there's a visualization to capture
            if (!state.current.child || !state.current.alterData) {
                alert('Please select a child and visualize the network first.');
                return;
            }
            
            // Get selected format
            const format = document.getElementById('screenshotFormat').value;
            
            // For SVG format, export directly (this always works)
            if (format === 'svg') {
                const svg = document.getElementById('networkSvg');
                if (!svg) {
                    alert('No network visualization found. Please visualize a network first.');
                    return;
                }
                
                const svgData = new XMLSerializer().serializeToString(svg);
                const svgBlob = new Blob([svgData], {type: 'image/svg+xml;charset=utf-8'});
                const svgUrl = URL.createObjectURL(svgBlob);
                
                const link = document.createElement('a');
                const childName = state.current.childData?.child_name || 'Unknown';
                const layoutStyle = state.ui.layoutStyle || 'grouped';
                const colorBy = state.ui.colorBy || 'default';
                const timestamp = new Date().toISOString().slice(0, 10);
                
                link.download = `network_${childName}_${layoutStyle}_${colorBy}_${timestamp}.svg`;
                link.href = svgUrl;
                link.click();
                
                URL.revokeObjectURL(svgUrl);
                alert('SVG saved successfully!');
                return;
            }
            
            // For PNG/JPG, use the simple approach: hide sidebar and capture main content
            try {
                // Hide the sidebar temporarily
                const sidebar = document.querySelector('.sidebar');
                const originalSidebarDisplay = sidebar ? sidebar.style.display : 'none';
                if (sidebar) {
                    sidebar.style.display = 'none';
                }
                
                // Hide the screenshot controls temporarily
                const screenshotControls = document.querySelector('.screenshot-controls');
                const originalControlsDisplay = screenshotControls ? screenshotControls.style.display : 'none';
                if (screenshotControls) {
                    screenshotControls.style.display = 'none';
                }
                
                // Wait a moment for the layout to adjust
                setTimeout(() => {
                    // Capture the main content area
                    const mainContent = document.querySelector('#childPage');
                    if (!mainContent) {
                        alert('Main content not found.');
                        restoreElements();
                        return;
                    }
                    
                    // Use html2canvas to capture the main content
                    html2canvas(mainContent, {
                        backgroundColor: 'white',
                        scale: 2,
                        useCORS: true,
                        allowTaint: true,
                        logging: false
                    }).then(canvas => {
                        // Create download link
                        const dataURL = format === 'jpg' ? 
                            canvas.toDataURL('image/jpeg', 0.9) : 
                            canvas.toDataURL('image/png', 1.0);
                        
                        const link = document.createElement('a');
                        link.href = dataURL;
                        
                        // Set filename
                        const childName = state.current.childData?.child_name || 'Unknown';
                        const layoutStyle = state.ui.layoutStyle || 'grouped';
                        const colorBy = state.ui.colorBy || 'default';
                        const timestamp = new Date().toISOString().slice(0, 10);
                        const fileExtension = format === 'jpg' ? 'jpg' : 'png';
                        
                        link.download = `network_${childName}_${layoutStyle}_${colorBy}_${timestamp}.${fileExtension}`;
                        link.click();
                        
                        // Restore elements
                        restoreElements();
                        
                        alert('Screenshot saved successfully!');
                    }).catch(error => {
                        console.error('Screenshot error:', error);
                        alert('Error taking screenshot. Please try again.');
                        restoreElements();
                    });
                }, 100);
                
                function restoreElements() {
                    // Restore sidebar
                    if (sidebar) {
                        sidebar.style.display = originalSidebarDisplay;
                    }
                    // Restore screenshot controls
                    if (screenshotControls) {
                        screenshotControls.style.display = originalControlsDisplay;
                    }
                }
            } catch (error) {
                console.error('Screenshot error:', error);
                alert('Error taking screenshot. Please try again.');
            }
        }
        
        // Header control functions for child page
        function toggleHeader() {
            const breadcrumb = document.getElementById('breadcrumb');
            const toggleIcon = document.getElementById('toggleIcon');
            
            if (!breadcrumb || !toggleIcon) {
                console.error('Header elements not found');
                return;
            }
            
            if (breadcrumb.classList.contains('collapsed')) {
                breadcrumb.classList.remove('collapsed');
                toggleIcon.textContent = '▼';
            } else {
                breadcrumb.classList.add('collapsed');
                toggleIcon.textContent = '▲';
            }
        }
        
        function startHeaderDrag(event) {
            event.preventDefault();
            event.stopPropagation();
            
            const breadcrumb = document.getElementById('breadcrumb');
            if (!breadcrumb) return;
            
            // Store initial position
            const initialLeft = parseInt(breadcrumb.style.left) || 400;
            const initialTop = parseInt(breadcrumb.style.top) || 80;
            
            // Store mouse start position
            const mouseStartX = event.clientX;
            const mouseStartY = event.clientY;
            
            breadcrumb.classList.add('dragging');
            
            function onMouseMove(e) {
                const deltaX = e.clientX - mouseStartX;
                const deltaY = e.clientY - mouseStartY;
                
                const newLeft = initialLeft + deltaX;
                const newTop = initialTop + deltaY;
                
                // Keep within viewport bounds
                const maxLeft = window.innerWidth - breadcrumb.offsetWidth;
                const maxTop = window.innerHeight - breadcrumb.offsetHeight;
                
                breadcrumb.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
                breadcrumb.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';
            }
            
            function onMouseUp() {
                breadcrumb.classList.remove('dragging');
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }
  
        function createGroupedVisualization() {
            console.log('createGroupedVisualization called with', state.current.alterData?.length || 0, 'alters');
            
            if (!state.current.alterData || state.current.alterData.length === 0) {
                console.log('No alter data available for visualization');
                return;
            }
  
            const svg = d3.select('#networkSvg');
            if (svg.empty()) {
                console.error('SVG element not found!');
                return;
            }
            
            // Show the network SVG and legend
            svg.style('display', 'block');
            
            // Hide welcome message
            const welcomeMessage = document.getElementById('welcomeMessage');
            if (welcomeMessage) {
                welcomeMessage.style.display = 'none';
            }
            
            // Show legend if it exists
            const legend = document.getElementById('legend');
            if (legend) {
                legend.style.display = 'block';
            }
            
            svg.selectAll('*').remove();
  
            const sidebar = document.getElementById('sidebar');
            const sidebarWidth = sidebar ? parseInt(getComputedStyle(sidebar).width, 10) : 340;
            const width = window.innerWidth - sidebarWidth;
            const height = window.innerHeight;
            
            // Add zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.75, 3])
                .on('zoom', (event) => {
                    container.attr('transform', event.transform);
                });
            
            svg.call(zoom);
            
            const container = svg.append('g').attr('class', 'main-container');
            
            // Create explicit SVG layers in correct order
            const backgroundLayer = container.append('g').attr('class', 'background-layer');
            const edgesLayer = container.append('g').attr('class', 'edges-layer');
            const nodesLayer = container.append('g').attr('class', 'nodes-layer');
  
            // Group alters by context
            const contextGroups = groupAltersByContext(state.current.alterData);
            
            // Create ego node
            const ego = {
                id: 'ego',
                name: state.current.childData?.child_name || 'Child',
                x: width / 2,
                y: height / 2,
                type: 'ego'
            };
  
            console.log('Layout style:', state.ui.layoutStyle, 'Context groups:', Object.keys(contextGroups));
            if (state.ui.layoutStyle === 'grouped') {
                console.log('Drawing grouped layout');
                drawGroupedLayout(container, ego, contextGroups, width, height);
            } else if (state.ui.layoutStyle === 'component') {
                console.log('Drawing component membership layout');
                drawComponentLayout(container, ego, contextGroups, width, height);
            } else {
                console.log('Drawing traditional layout');
                drawTraditionalLayout(container, ego, contextGroups, width, height);
            }
        }
  
        function normId(x) {
            return String(x || '').trim().toLowerCase();
        }
  
        function edgeEnd(a, b, ra, rb) {
            const dx = b.x - a.x, dy = b.y - a.y;
            const d = Math.hypot(dx, dy) || 1;
            const ux = dx / d, uy = dy / d, pad = 2;
            return {
                x1: a.x + ux * (ra + pad), y1: a.y + uy * (ra + pad),
                x2: b.x - ux * (rb + pad), y2: b.y - uy * (rb + pad)
            };
        }
  
        function canonRace(r) {
            r = String(r || '').toLowerCase().trim();
            if (!r) return 'Other';
            
            // Handle comma-separated values by taking the first one
            if (r.includes(',')) {
                r = r.split(',')[0].trim();
            }
            
            if (r.includes('white')) return 'White';
            if (r.includes('black') || r.includes('african')) return 'Black';
            if (r.includes('hisp') || r.includes('latino') || r.includes('latinx')) return 'Hispanic/Latino';
            if (r.includes('asian')) return 'Asian';
            if (r.includes('native') && (r.includes('american') || r.includes('alaska'))) return 'Native/Alaska';
            if (r.includes('middle east') || r.includes('mena') || r.includes('north africa')) return 'MENA';
            if (r.includes('mixed') || r.includes('multi')) return 'Multiracial';
            return 'Other';
        }
  
        function canonKin(v) {
            const s = String(v || '').toLowerCase().trim();
            if (s === '1' || s === 'y' || s === 'yes' || s === 'true') return 'Yes';
            return 'No';
        }
  
        function parseContactContext(contextText) {
            if (!contextText) return 'Unknown';
            
            // Split by semicolon and process each part
            const parts = String(contextText).split(/[;,]/).map(part => part.trim()).filter(part => part.length > 0);
            const contexts = new Set(); // Use Set to avoid duplicates
            
            parts.forEach(part => {
                const text = part.toLowerCase();
                
                if (text.includes('at home') || text.includes('family member who lives at home')) {
                    contexts.add('At home');
                } else if (text.includes('extended family')) {
                    contexts.add('Extended Family');
                } else if (text.includes('daycare') || text.includes('school')) {
                    contexts.add('Daycare/School');
                } else if (text.includes('activity1') || text.includes('activity 1')) {
                    contexts.add('Activity 1');
                } else if (text.includes('activity2') || text.includes('activity 2')) {
                    contexts.add('Activity 2');
                } else if (text.includes('activity3') || text.includes('activity 3')) {
                    contexts.add('Activity 3');
                } else if (text.includes('activity4') || text.includes('activity 4')) {
                    contexts.add('Activity 4');
                } else if (text.includes('activity5') || text.includes('activity 5')) {
                    contexts.add('Activity 5');
                } else if (text.includes('activity6') || text.includes('activity 6')) {
                    contexts.add('Activity 6');
                } else if (text.includes('activity7') || text.includes('activity 7')) {
                    contexts.add('Activity 7');
                } else if (part.trim().length > 0) {
                    // Only add "Other" if there's actual content that doesn't match any category
                    contexts.add('Other');
                }
            });
            
            // Return comma-separated list or "Unknown" if no contexts found
            return contexts.size > 0 ? Array.from(contexts).join(', ') : 'Unknown';
        }
  
        function parseAlterEdges(alterData) {
            const edges = [];
            const nodeMap = new Map();
            
            // Create mapping of normalized node_mapping_code to alter data
            alterData.forEach((alter, index) => {
                const originalId = alter.node_mapping_code || `alter_${index}`;
                const normalizedId = normId(originalId);
                if (normalizedId) {
                    nodeMap.set(normalizedId, { ...alter, originalId });
                }
            });
            
            // Parse node_mapping field to extract connections
            alterData.forEach((alter, index) => {
                const sourceOriginalId = alter.node_mapping_code || `alter_${index}`;
                const sourceId = normId(sourceOriginalId);
                const nodeMapping = alter.node_mapping;
                
                if (nodeMapping && typeof nodeMapping === 'string' && sourceId) {
                    // Parse the node_mapping field - support comma, semicolon, space separation
                    const connections = nodeMapping.split(/[,;\s]+/).filter(id => id.trim());
                    
                    connections.forEach(targetCode => {
                        const targetId = normId(targetCode);
                        if (targetId && targetId !== sourceId && nodeMap.has(targetId)) {
                            // Store edges with normalized endpoints
                            const edge = sourceId < targetId ? 
                                { source: sourceId, target: targetId } :
                                { source: targetId, target: sourceId };
                            
                            // Check if edge already exists
                            if (!edges.some(e => e.source === edge.source && e.target === edge.target)) {
                                edges.push(edge);
                            }
                        }
                    });
                }
            });
            
            return edges;
        }
  
        function applyFilters(alterData) {
            return alterData.filter(alter => {
                // Gender filter
                if (state.ui.filters.gender.size > 0 && !state.ui.filters.gender.has(alter.node_gender || 'Unknown')) {
                    console.warn('FILTER_DROP', {
                        child: state.current.child, 
                        id: alter.node_mapping_code, 
                        name: alter.node_name, 
                        reason: 'gender/no-match',
                        value: alter.node_gender
                    });
                    return false;
                }
                
                // Race filter (with canonicalization)
                if (state.ui.filters.race.size > 0) {
                    const canonicalRace = canonRace(alter.node_race);
                    if (!state.ui.filters.race.has(canonicalRace)) {
                        console.warn('FILTER_DROP', {
                            child: state.current.child, 
                            id: alter.node_mapping_code, 
                            name: alter.node_name, 
                            reason: 'race/no-match',
                            value: alter.node_race,
                            canonical: canonicalRace
                        });
                        return false;
                    }
                }
                
                // Language filter (multilingual support) - use new normLangList
                if (state.ui.filters.language.size > 0) {
                    const langs = new Set(normLangList(alter.node_language));
                    const has = [...state.ui.filters.language].some(opt => langs.has(String(opt).toLowerCase()));
                    if (!has) {
                        console.warn('FILTER_DROP', {
                            child: state.current.child, 
                            id: alter.node_mapping_code, 
                            name: alter.node_name, 
                            reason: 'language/no-intersection',
                            value: alter.node_language,
                            normalized: Array.from(langs)
                        });
                        return false;
                    }
                }
                
                // Kin filter (with canonicalization)
                if (state.ui.filters.kin.size > 0) {
                    const canonicalKin = canonKin(alter.node_kin);
                    if (!state.ui.filters.kin.has(canonicalKin)) {
                        console.warn('FILTER_DROP', {
                            child: state.current.child, 
                            id: alter.node_mapping_code, 
                            name: alter.node_name, 
                            reason: 'kin/no-match',
                            value: alter.node_kin,
                            canonical: canonicalKin
                        });
                        return false;
                    }
                }
                
                // Mode of contact filter
                if (state.ui.filters.contactMode.size > 0 && !state.ui.filters.contactMode.has(alter.node_mode_of_contact || 'Unknown')) {
                    console.warn('FILTER_DROP', {
                        child: state.current.child, 
                        id: alter.node_mapping_code, 
                        name: alter.node_name, 
                        reason: 'contact-mode/no-match',
                        value: alter.node_mode_of_contact
                    });
                    return false;
                }
                
                // Contact context filter
                if (state.ui.filters.contactContext.size > 0) {
                    const canonicalContext = parseContactContext(alter.node_context);
                    if (!state.ui.filters.contactContext.has(canonicalContext)) {
                        console.warn('FILTER_DROP', {
                            child: state.current.child, 
                            id: alter.node_mapping_code, 
                            name: alter.node_name, 
                            reason: 'contact-context/no-match',
                            value: alter.node_context,
                            canonical: canonicalContext
                        });
                        return false;
                    }
                }
                
                // Age category filter
                if (state.ui.filters.ageCategory.size > 0 && !state.ui.filters.ageCategory.has(alter.node_age_categorized || 'Unknown')) {
                    console.warn('FILTER_DROP', {
                        child: state.current.child, 
                        id: alter.node_mapping_code, 
                        name: alter.node_name, 
                        reason: 'age-category/no-match',
                        value: alter.node_age_categorized
                    });
                    return false;
                }
                
                // Weekly hours filter
                const weeklyHours = parseFloat(alter.node_weekly_hour_summarized || alter.node_weekly_hour || 0);
                if (weeklyHours < state.ui.filters.minWeeklyHours) {
                    console.warn('FILTER_DROP', {
                        child: state.current.child, 
                        id: alter.node_mapping_code, 
                        name: alter.node_name, 
                        reason: 'weekly-hours/below-minimum',
                        value: weeklyHours,
                        minimum: state.ui.filters.minWeeklyHours
                    });
                    return false;
                }
                
                // Closeness filter
                const closeness = parseFloat(alter.node_closeness_score || 0);
                if (closeness < state.ui.filters.minCloseness) {
                    console.warn('FILTER_DROP', {
                        child: state.current.child, 
                        id: alter.node_mapping_code, 
                        name: alter.node_name, 
                        reason: 'closeness/below-minimum',
                        value: closeness,
                        minimum: state.ui.filters.minCloseness
                    });
                    return false;
                }
                
                return true;
            });
        }
  
        function groupAltersByContext(alterData) {
            console.log('groupAltersByContext called with', alterData?.length || 0, 'alters');
            // Apply filters first
            const filteredData = applyFilters(alterData);
            console.log('After filtering:', filteredData?.length || 0, 'alters remain');
            const groups = {};
            
            filteredData.forEach((alter, index) => {
                const context = canonContext(alter.node_type);
                const contextKey = getContextKey(context, alter);
                
                if (!groups[contextKey]) {
                    groups[contextKey] = {
                        context: context,
                        label: getContextLabel(context, alter),
                        color: getContextColor(context),
                        alters: []
                    };
                }
                
                groups[contextKey].alters.push({
                    id: normId(alter.node_mapping_code) || `alter_${index}`,
                    name: alter.node_name || `${alter.node_type}_${index}`,
                    data: alter,
                    context: context
                });
            });
  
            // Self-test for Orca child
            if (state.current.child === 'Orca') {
                const must = {
                    caregiver: ['Jolly'],
                    daycare: ['Amy','Willy'],
                    extended_family: ['Nana','Eugene'],
                    home: ['Molly','Tom'],
                    sibling: ['Bentley','Georgie'],
                    'activity_1': ['Jen','Gigi'],
                    'activity_2': ['Orleo','Joey'],
                    anyoneelse: ['Hookie']
                };
                const misses = [];
                for (const [ctx, names] of Object.entries(must)) {
                    const have = new Set((groups[ctx]?.alters||[]).map(a=>a.name));
                    names.forEach(n => { if (!have.has(n)) misses.push(`${ctx}:${n}`); });
                }
                if (misses.length) {
                    console.error('CONTEXT_ASSIGNMENT_FAIL', misses, {
                        preview: Object.fromEntries(Object.entries(groups).map(([k,v])=>[k,(v.alters||[]).map(a=>a.name)]))
                    });
                }
            }
  
            return groups;
        }
  
        function groupAltersByComponent(contextGroups) {
            // Extract all alters from context groups and regroup by component membership
            const componentGroups = {};
            
            Object.values(contextGroups).forEach(contextGroup => {
                contextGroup.alters.forEach(alter => {
                    const componentId = alter.data.component_membership || 'Component 1';
                    
                    if (!componentGroups[componentId]) {
                        componentGroups[componentId] = {
                            componentId: componentId,
                            label: `Component ${componentId}`,
                            color: getComponentColor(componentId),
                            alters: []
                        };
                    }
                    
                    componentGroups[componentId].alters.push(alter);
                });
            });
            
            return componentGroups;
        }
  
        function getComponentColor(componentId) {
            // Generate distinct colors for different components
            const colors = ['#ffb3ba', '#ffdfba', '#baffc9', '#bae1ff', '#d4baff', '#ffb3d9', '#b3ffba'];
            const index = parseInt(componentId.replace(/\D/g, '')) - 1;
            return colors[index % colors.length] || '#cccccc';
        }
  
        function determineContext(alter) {
            // Legacy wrapper - use canonContext instead
            return canonContext(alter.node_type);
        }
  
        function getContextKey(context, alter) {
            if (context.startsWith('activity_')) {
                const activityId = context.split('_')[1];
                const activityData = state.data.activityIndex[state.current.child]?.[activityId];
                return `activity_${activityId}_${activityData?.activity_name || 'Unknown'}`;
            }
            return context;
        }
  
        function getContextLabel(context, alter) {
            if (context.startsWith('activity_')) {
                const activityId = context.split('_')[1];
                const activityData = state.data.activityIndex[state.current.child]?.[activityId];
                return `Activity ${activityId}: ${activityData?.activity_name || 'Unknown'}`;
            }
            return CONTEXTS[context]?.label || context.charAt(0).toUpperCase() + context.slice(1);
        }
  
        function getContextColor(context) {
            if (context.startsWith('activity_')) {
                const activityId = context.split('_')[1];
                const activityNum = parseInt(activityId) - 1;
                return ACTIVITY_COLORS[activityNum % ACTIVITY_COLORS.length] || CONTEXTS.activity.color;
            }
            return CONTEXTS[context]?.color || CONTEXTS.anyoneelse.color;
        }
  
        function drawGroupedLayout(container, ego, contextGroups, width, height) {
            const groups = Object.entries(contextGroups).filter(([key, group]) => {
                const baseContext = group.context.startsWith('activity_') ? 'activity' : group.context;
                return state.ui.visibleContexts.has(baseContext);
            });
  
            // Calculate positions for context boxes
            const positions = calculateGroupPositions(groups.length, width, height, ego);
            
            // Create a map of alter IDs to their positions (will be populated after drawing context boxes)
            const alterPositions = new Map();
            
            // Get the explicit layers from the container
            const backgroundLayer = container.select('.background-layer');
            const edgesLayer = container.select('.edges-layer');
            const nodesLayer = container.select('.nodes-layer');
            
            // Removed ego-to-context dash lines for grouped layout as requested
            
            // Draw context boxes in background layer
            groups.forEach(([key, group], i) => {
                const pos = positions[i];
                drawContextBox(backgroundLayer, group, pos, key, alterPositions);
            });
            
            // Draw alter-alter edges in edges layer (above background, below nodes)
            if (state.current.alterEdges.length > 0) {
                drawAlterEdges(edgesLayer, alterPositions);
            }
  
            // Draw ego node in nodes layer (on top)
            drawEgoNode(nodesLayer, ego);
            
            // Update legends
            updateLegend();
            updateSizeLegend();
        }
  
        function drawComponentLayout(container, ego, contextGroups, width, height) {
            // Group alters by component membership instead of context
            const componentGroups = groupAltersByComponent(contextGroups);
            
            // Calculate positions for component boxes
            const positions = calculateGroupPositions(Object.keys(componentGroups).length, width, height, ego);
            
            // Create a map of alter IDs to their positions
            const alterPositions = new Map();
            
            // Get the explicit layers from the container
            const backgroundLayer = container.select('.background-layer');
            const edgesLayer = container.select('.edges-layer');
            const nodesLayer = container.select('.nodes-layer');
            
            // Note: Ego-to-component connections removed for cleaner component view
            
            // Draw component boxes in background layer
            Object.entries(componentGroups).forEach(([componentId, group], i) => {
                const pos = positions[i];
                drawComponentBox(backgroundLayer, group, pos, componentId, alterPositions);
            });
            
            // Draw alter-alter edges in edges layer (above background, below nodes)
            if (state.current.alterEdges.length > 0) {
                drawAlterEdges(edgesLayer, alterPositions);
            }
  
            // Draw ego node in nodes layer (on top)
            drawEgoNode(nodesLayer, ego);
            
            // Update legends
            updateLegend();
            updateSizeLegend();
        }
  
        function drawComponentBox(container, group, position, componentId, alterPositions) {
            // Similar to drawContextBox but for component membership
            const alters = group.alters;
            const boxPadding = 20;
            const nodeRadius = 25;
            const spacing = nodeRadius * 3.5; // INCREASED SPACING from 2.2 to 3.5
            
            // Calculate box dimensions - simplified since labels are inside circles
            const cols = Math.ceil(Math.sqrt(alters.length));
            const rows = Math.ceil(alters.length / cols);
            const minSpacing = 60; // Minimum distance between node centers
            const actualSpacing = Math.max(spacing, minSpacing);
            const boxWidth = Math.max(140, cols * actualSpacing + boxPadding * 2);
            const boxHeight = Math.max(80, rows * actualSpacing + boxPadding * 2 + 30);
            
            // Position box
            const boxX = position.x - boxWidth / 2;
            const boxY = position.y - boxHeight / 2;
            
            // Create component box group with drag functionality
            const boxGroup = container.append('g')
                .attr('class', 'component-box')
                .attr('data-component-id', componentId)
                .style('cursor', 'move');
            
            // Draw box background
            boxGroup.append('rect')
                .attr('x', boxX)
                .attr('y', boxY)
                .attr('width', boxWidth)
                .attr('height', boxHeight)
                .attr('rx', 12)
                .attr('ry', 12)
                .style('fill', group.color)
                .style('stroke', '#495057')
                .style('stroke-width', 2)
                .style('opacity', 0.8);
            
            // Draw box label
            boxGroup.append('text')
                .attr('x', position.x)
                .attr('y', boxY + 20)
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .style('fill', '#2c3e50')
                .text(group.label);
            
            // Position and draw alters within the box (same logic as drawContextBox)
            alters.forEach((alter, i) => {
                const col = i % cols;
                const row = Math.floor(i / cols);
                const alterX = boxX + boxPadding + col * actualSpacing + actualSpacing / 2;
                const alterY = boxY + boxPadding + 30 + row * actualSpacing + actualSpacing / 2;
                
                alter.x = alterX;
                alter.y = alterY;
                
                // Ensure alter.id is normalized consistently
                alter.id = normId(alter.data.node_mapping_code) || `alter_${i}`;
                
                // Store position for edge drawing
                if (alterPositions) {
                    alterPositions.set(alter.id, { x: alterX, y: alterY });
                }
                
                // Get node size and positioning info
                const nodeRadius = getNodeSize(alter);
                
                // Draw alter node (same as in drawContextBox)
                const alterGroup = boxGroup.append('g')
                    .attr('class', 'alter-node')
                    .datum({
                        id: alter.id,
                        x: alterX,
                        y: alterY,
                        data: alter.data,
                        name: alter.name
                    })
                    .style('cursor', 'pointer')
                    .on('click', (event) => {
                        event.stopPropagation();
                        selectAlterNode(alter);
                    });
  
                // Handle pie charts for multilingual nodes OR multi-race nodes
                let shouldDrawPieChart = false;
                let pieData = [];
                let piePalette = {};
                
                if (state.ui.colorBy === 'language') {
                    const languages = normalizeLanguage(alter.data.node_language);
                    if (languages.length > 1) {
                        shouldDrawPieChart = true;
                        pieData = languages;
                        piePalette = {
                            'English': '#1f77b4',
                            'German': '#ff7f0e', 
                            'Spanish': '#2ca02c',
                            'Portuguese': '#d62728',
                            'Italian': '#9467bd',
                            'Thai': '#8c564b',
                            'Pre-verbal/Non-verbal': '#7f7f7f',
                            'Unknown': '#cccccc'
                        };
                    }
                } else if (state.ui.colorBy === 'race') {
                    const races = normalizeRace(alter.data.node_race);
                    if (races.length > 1) {
                        shouldDrawPieChart = true;
                        pieData = races;
                        piePalette = {
                            'White': '#76b7b2',
                            'Black': '#59a14f',
                            'Hispanic/Latino': '#edc949',
                            'Asian': '#af7aa1',
                            'Native/Alaska': '#8dd3c7',
                            'MENA': '#fb8072',
                            'Multiracial': '#bc80bd',
                            'Other': '#d9d9d9'
                        };
                    }
                }
                
                if (shouldDrawPieChart) {
                    // Create clipPath for pie chart nodes
                    const clipId = `clip-${alter.id}`;
                    const defs = alterGroup.append('defs');
                    defs.append('clipPath')
                        .attr('id', clipId)
                        .append('circle')
                        .attr('cx', alterX)
                        .attr('cy', alterY)
                        .attr('r', nodeRadius);
                    
                    // Create pie wedges
                    const pieGroup = alterGroup.append('g')
                        .attr('clip-path', `url(#${clipId})`);
                    
                    const anglePerSlice = (2 * Math.PI) / pieData.length;
                    pieData.forEach((item, i) => {
                        const startAngle = i * anglePerSlice - Math.PI / 2; // Start from top
                        const endAngle = (i + 1) * anglePerSlice - Math.PI / 2;
                        
                        const x1 = alterX + nodeRadius * Math.cos(startAngle);
                        const y1 = alterY + nodeRadius * Math.sin(startAngle);
                        const x2 = alterX + nodeRadius * Math.cos(endAngle);
                        const y2 = alterY + nodeRadius * Math.sin(endAngle);
                        
                        const largeArcFlag = anglePerSlice > Math.PI ? 1 : 0;
                        const pathData = `M ${alterX} ${alterY} L ${x1} ${y1} A ${nodeRadius} ${nodeRadius} 0 ${largeArcFlag} 1 ${x2} ${y2} Z`;
                        
                        pieGroup.append('path')
                            .attr('d', pathData)
                            .style('fill', piePalette[item] || '#cccccc')
                            .style('stroke', 'none');
                    });
                    
                    // Add stroke around the whole circle
                    alterGroup.append('circle')
                        .attr('cx', alterX)
                        .attr('cy', alterY)
                        .attr('r', nodeRadius)
                        .style('fill', 'none')
                        .style('stroke', '#666666')
                        .style('stroke-width', 3);
                } else {
                    // Regular circle for single values or other color modes
                    let nodeColor = state.ui.colorBy === 'context' ? 'white' : getNodeColor(alter, 'white');
                    const strokeColor = state.ui.colorBy === 'context' ? group.color : '#666666';
                    
                    // If this alter is selected, make it red
                    if (state.ui.selectedAlter && state.ui.selectedAlter.id === alter.id) {
                        nodeColor = '#ef4444'; // Red for selected alter
                    } else if (state.ui.colorBy === 'context') {
                        // Check if this alter is connected to the selected alter
                        const isConnectedToSelected = state.ui.selectedAlter && 
                            state.current.alterEdges.some(edge => 
                                (edge.source === alter.id && edge.target === state.ui.selectedAlter.id) ||
                                (edge.target === alter.id && edge.source === state.ui.selectedAlter.id)
                            );
                        
                        if (isConnectedToSelected) {
                            nodeColor = '#ffa500'; // Orange for alters connected to selected alter
                        } else {
                            nodeColor = 'white'; // White for other alters (context color)
                        }
                    }
                    
                    alterGroup.append('circle')
                        .attr('cx', alterX)
                        .attr('cy', alterY)
                        .attr('r', nodeRadius)
                        .style('fill', nodeColor)
                        .style('stroke', strokeColor)
                        .style('stroke-width', 3);
                }
                
                // Add label text INSIDE the circle with auto-fit
                const labelCore = alterGroup.append('text')
                    .attr('x', alterX)
                    .attr('y', alterY)
                    .style('text-anchor', 'middle')
                    .style('dominant-baseline', 'middle')
                    .style('font-size', '12px')
                    .style('font-weight', '600')
                    .style('fill', '#2c3e50')
                    .style('pointer-events', 'auto')
                    .style('cursor', 'pointer')
                    .style('text-shadow', '0 0 3px rgba(255,255,255,0.8)')
                    .text(getAnonymizedText(alter, false))
                    .on('click', (event) => {
                        event.stopPropagation();
                        selectAlterNode(alter);
                    });
                if (typeof fitTextToCircle === 'function') { fitTextToCircle(labelCore.node(), nodeRadius); }
  
                // Add metric label under name based on sizing mode
                if (state.ui.nodeSizeBy === 'weekly_hours') {
                    const weeklyHours = parseFloat(alter.data.node_weekly_hour_summarized || alter.data.node_weekly_hour || 0);
                    alterGroup.append('text')
                        .attr('x', alterX)
                        .attr('y', alterY + 8)
                        .style('text-anchor', 'middle')
                        .style('dominant-baseline', 'middle')
                        .style('font-size', '8px')
                        .style('font-weight', '400')
                        .style('fill', '#6c757d')
                        .style('pointer-events', 'none')
                        .text(`${weeklyHours}h`);
                } else if (state.ui.nodeSizeBy === 'closeness') {
                    const closeness = parseFloat(alter.data.node_closeness_score || 0);
                    alterGroup.append('text')
                        .attr('x', alterX)
                        .attr('y', alterY + 8)
                        .style('text-anchor', 'middle')
                        .style('dominant-baseline', 'middle')
                        .style('font-size', '8px')
                        .style('font-weight', '400')
                        .style('fill', '#6c757d')
                        .style('pointer-events', 'none')
                        .text(`${Math.round(isNaN(closeness) ? 0 : closeness)}`);
                } else if (state.ui.nodeSizeBy === 'closeness_intensity_z') {
                    const zScore = getClosenessIntensityZFromData(alter.data);
                    alterGroup.append('text')
                        .attr('x', alterX)
                        .attr('y', alterY + 8)
                        .style('text-anchor', 'middle')
                        .style('dominant-baseline', 'middle')
                        .style('font-size', '8px')
                        .style('font-weight', '400')
                        .style('fill', '#6c757d')
                        .style('pointer-events', 'none')
                        .text(zScore.toFixed(2));
                }
  
                // Add survey respondent indicator if applicable
                if (isShowingRespondent(alter)) {
                    alterGroup.classed('survey-respondent', true);
                }
            });
            
            // Add drag functionality to the component box
            let initialTransform = { x: 0, y: 0 };
            
            boxGroup.call(d3.drag()
                .on('start', function(event, d) {
                    d3.select(this).style('opacity', 0.8);
                    initialTransform.x = 0;
                    initialTransform.y = 0;
                })
                .on('drag', function(event, d) {
                    // Calculate relative movement from start of drag
                    initialTransform.x += event.dx;
                    initialTransform.y += event.dy;
                    
                    // Apply transform to follow mouse smoothly
                    d3.select(this).attr('transform', `translate(${initialTransform.x}, ${initialTransform.y})`);
                    
                    // Redraw edges that connect to this component
                    redrawAlterEdges();
                })
                .on('end', function(event, d) {
                    d3.select(this).style('opacity', 1);
                    
                    // Apply final displacement to position and alter data
                    const finalDx = initialTransform.x;
                    const finalDy = initialTransform.y;
                    
                    position.x += finalDx;
                    position.y += finalDy;
                    
                    group.alters.forEach(alter => {
                        alter.x += finalDx;
                        alter.y += finalDy;
                        if (alterPositions && alterPositions.has(alter.id)) {
                            const pos = alterPositions.get(alter.id);
                            alterPositions.set(alter.id, {
                                x: pos.x + finalDx,
                                y: pos.y + finalDy
                            });
                        }
                    });
                    
                    // Update data bound to DOM elements
                    d3.select(this).selectAll('.alter-node').each(function() {
                        const currentData = d3.select(this).datum();
                        if (currentData) {
                            currentData.x += finalDx;
                            currentData.y += finalDy;
                        }
                    });
                    
                    // Reset transform and apply position changes directly
                    d3.select(this).attr('transform', null);
                    
                    // Redraw component at new permanent position
                    d3.select(this).selectAll('rect')
                        .attr('x', position.x - (boxWidth / 2))
                        .attr('y', position.y - (boxHeight / 2));
                    
                    d3.select(this).selectAll('text')
                        .attr('x', position.x)
                        .attr('y', position.y - (boxHeight / 2) + 20);
                    
                    // Update alter positions in DOM
                    d3.select(this).selectAll('.alter-node').each(function(alterData) {
                        if (alterData && typeof alterData.x === 'number' && typeof alterData.y === 'number') {
                            const alterGroup = d3.select(this);
                            alterGroup.selectAll('circle')
                                .attr('cx', alterData.x)
                                .attr('cy', alterData.y);
                            alterGroup.selectAll('text')
                                .attr('x', alterData.x)
                                .attr('y', alterData.y);
                        }
                    });
                    
                    // Final edge redraw with permanent positions
                    redrawAlterEdges();
                }));
        }
  
        function drawAlterEdges(container, alterPositions) {
            // Clear existing edges
            container.selectAll('*').remove();
            
            // Initialize edge visibility if not set
            if (!state.ui.edgeVisibility) {
                state.ui.edgeVisibility = 'all'; // Default to showing all edges
            }
            
            // Filter edges based on visibility setting
            let edgesToDraw = [];
            
            if (state.ui.edgeVisibility === 'all') {
                // Show ALL edges - this is the default view
                edgesToDraw = state.current.alterEdges;
            } else if (state.ui.edgeVisibility === 'ego-only') {
                // No alter-alter edges in ego-only mode
                edgesToDraw = [];
            } else if (state.ui.edgeVisibility === 'selected-only') {
                // Only show edges connected to selected alter
                if (state.ui.selectedAlter) {
                    edgesToDraw = state.current.alterEdges.filter(edge => 
                        edge.source === state.ui.selectedAlter.id || edge.target === state.ui.selectedAlter.id
                    );
                } else {
                    // If no alter is selected, show no edges
                    edgesToDraw = [];
                }
            }
            
            if (edgesToDraw.length === 0) {
                return;
            }
            edgesToDraw.forEach((edge, index) => {
                const sourcePos = alterPositions.get(edge.source);
                const targetPos = alterPositions.get(edge.target);
                
                if (sourcePos && targetPos) {
                    // Check if this edge is connected to selected alter
                    const isSelectedEdge = state.ui.selectedAlter && 
                        (edge.source === state.ui.selectedAlter.id || edge.target === state.ui.selectedAlter.id);
                    
                    // Determine edge color and styling based on visibility mode and selection
                    let edgeColor, edgeWidth, edgeOpacity;
                    
                    // For edge visibility 'all', we'll use CSS classes for styling
                    // The actual colors will be applied via CSS classes in updateNodeSelection
                    
                    if (state.ui.edgeVisibility === 'selected-only') {
                        // In selected-only mode, all visible edges are red (selected)
                        edgeColor = '#ef4444';  // Red
                        edgeWidth = '3.5';
                        edgeOpacity = '0.95';
                    } else {
                        // For 'all' and 'ego-only' modes, use default styling
                        // The selected edges will be highlighted via CSS classes
                        edgeColor = '#4A5568';  // Default gray
                        edgeWidth = '1.5';
                        edgeOpacity = '0.35';
                    }
                    
                    // Get node sizes for edge endpoint calculation
                    const sourceAlter = state.current.alterData.find(a => 
                        normId(a.node_mapping_code) === edge.source
                    );
                    const targetAlter = state.current.alterData.find(a => 
                        normId(a.node_mapping_code) === edge.target
                    );
                    
                    const sourceRadius = sourceAlter ? getNodeSize({data: sourceAlter}) : 20;
                    const targetRadius = targetAlter ? getNodeSize({data: targetAlter}) : 20;
                    
                    // Check if both nodes are in the same context box
                    const sameBox = areSameContextBox(edge.source, edge.target);
                    
                    if (sameBox) {
                        // Draw curved edge within the same box (from perimeter to perimeter)
                        const endpoints = edgeEnd(sourcePos, targetPos, sourceRadius, targetRadius);
                        const midX = (endpoints.x1 + endpoints.x2) / 2;
                        const midY = (endpoints.y1 + endpoints.y2) / 2;
                        const distance = Math.sqrt(Math.pow(endpoints.x2 - endpoints.x1, 2) + Math.pow(endpoints.y2 - endpoints.y1, 2));
                        const curvature = Math.min(distance * 0.2, 20);
                        
                        // Calculate control point perpendicular to the line
                        const dx = endpoints.x2 - endpoints.x1;
                        const dy = endpoints.y2 - endpoints.y1;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const perpX = length > 0 ? -dy / length * curvature : 0;
                        const perpY = length > 0 ? dx / length * curvature : 0;
                        
                        const path = `M ${endpoints.x1} ${endpoints.y1} Q ${midX + perpX} ${midY + perpY} ${endpoints.x2} ${endpoints.y2}`;
                        
                        const edgeElement = container.append('path')
                            .attr('class', 'alter-edge')
                            .attr('d', path)
                            .style('stroke', edgeColor)
                            .style('stroke-width', edgeWidth)
                            .style('stroke-linecap', 'round')
                            .style('opacity', edgeOpacity)
                            .style('fill', 'none')
                            .style('pointer-events', 'auto')
                            .attr('data-source', edge.source)
                            .attr('data-target', edge.target);
                        

                    } else {
                        // Draw straight line across boxes (from perimeter to perimeter)
                        const endpoints = edgeEnd(sourcePos, targetPos, sourceRadius, targetRadius);
                        
                        const edgeElement = container.append('line')
                            .attr('class', 'alter-edge')
                            .attr('x1', endpoints.x1)
                            .attr('y1', endpoints.y1)
                            .attr('x2', endpoints.x2)
                            .attr('y2', endpoints.y2)
                            .style('stroke', edgeColor)
                            .style('stroke-width', edgeWidth)
                            .style('stroke-linecap', 'round')
                            .style('opacity', edgeOpacity)
                            .style('pointer-events', 'auto')
                            .attr('data-source', edge.source)
                            .attr('data-target', edge.target);
                        

                    }
                }
            });
        }
  
        function redrawAlterEdges() {
            // Redraw edges for both layout styles when needed
            if (state.ui.layoutStyle === 'component') {
                const container = d3.select('#networkSvg').select('.edges-layer');
                const alterPositions = new Map();
                
                // Collect current alter positions from all component boxes
                d3.selectAll('.component-box').each(function() {
                    const boxGroup = d3.select(this);
                    const transform = boxGroup.attr('transform');
                    let transformX = 0, transformY = 0;
                    
                    // Parse transform if exists
                    if (transform) {
                        const match = transform.match(/translate\(([^,)]+),([^)]+)\)/);
                        if (match) {
                            transformX = parseFloat(match[1]);
                            transformY = parseFloat(match[2]);
                        }
                    }
                    
                    // Find all alter nodes within this component box
                    boxGroup.selectAll('.alter-node').each(function(d) {
                        if (d && d.id && typeof d.x === 'number' && typeof d.y === 'number') {
                            const x = d.x + transformX;
                            const y = d.y + transformY;
                            alterPositions.set(d.id, { x, y });
                        }
                    });
                });
                
                // Redraw edges with updated positions
                drawAlterEdges(container, alterPositions);
            } else if (state.ui.layoutStyle === 'grouped') {
                // For grouped context layout, use the existing function
                redrawContextBoxEdges();
            }
        }
  
        function areSameContextBox(sourceId, targetId) {
            // Find the context groups for both nodes
            let sourceContext = null;
            let targetContext = null;
            
            // This is a simplified check - in practice, you'd maintain context mappings
            const sourceAlter = state.current.alterData.find(a => 
                normId(a.node_mapping_code) === sourceId
            );
            const targetAlter = state.current.alterData.find(a => 
                normId(a.node_mapping_code) === targetId
            );
            
            if (sourceAlter && targetAlter) {
                sourceContext = canonContext(sourceAlter.node_type);
                targetContext = canonContext(targetAlter.node_type);
                
                // For activities, check if they're the same specific activity
                if (sourceContext.startsWith('activity_') && targetContext.startsWith('activity_')) {
                    return sourceContext === targetContext;
                }
                
                return sourceContext === targetContext;
            }
            
            return false;
        }
        
        function redrawContextBoxEdges() {
            // Redraw edges for grouped context layout when boxes are dragged
            if (state.ui.layoutStyle === 'grouped') {
                const container = d3.select('#networkSvg').select('.edges-layer');
                const alterPositions = new Map();
                
                // Collect current alter positions from all context boxes
                d3.selectAll('.context-box').each(function() {
                    const boxGroup = d3.select(this);
                    const transform = boxGroup.attr('transform');
                    let transformX = 0, transformY = 0;
                    
                    // Parse transform if exists
                    if (transform) {
                        const match = transform.match(/translate\(([^,)]+),([^)]+)\)/);
                        if (match) {
                            transformX = parseFloat(match[1]);
                            transformY = parseFloat(match[2]);
                        }
                    }
                    
                    // Find all alter nodes within this context box
                    boxGroup.selectAll('.alter-node').each(function(d) {
                        if (d && d.id && typeof d.x === 'number' && typeof d.y === 'number') {
                            const x = d.x + transformX;
                            const y = d.y + transformY;
                            alterPositions.set(d.id, { x, y });
                        }
                    });
                });
                
                // Redraw edges with updated positions
                drawAlterEdges(container, alterPositions);
            }
        }
  
        function calculateGroupPositions(groupCount, width, height, ego) {
            const positions = [];
            const radius = Math.min(width, height) * 0.35;
            const centerX = ego.x;
            const centerY = ego.y;
            
            for (let i = 0; i < groupCount; i++) {
                const angle = (i / groupCount) * 2 * Math.PI - Math.PI / 2;
                positions.push({
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                });
            }
            
            return positions;
        }
  
        function drawContextBox(container, group, position, groupKey, alterPositions) {
            const alters = group.alters;
            const boxPadding = 20;
            const nodeRadius = 25;
            const spacing = nodeRadius * 3.5; // INCREASED SPACING from 2.2 to 3.5
            
            // Calculate box dimensions - simplified since labels are inside circles
            const cols = Math.ceil(Math.sqrt(alters.length));
            const rows = Math.ceil(alters.length / cols);
            const minSpacing = 60; // Minimum distance between node centers
            const actualSpacing = Math.max(spacing, minSpacing);
            const boxWidth = Math.max(140, cols * actualSpacing + boxPadding * 2);
            const boxHeight = Math.max(80, rows * actualSpacing + boxPadding * 2 + 30);
            
            // Position box
            const boxX = position.x - boxWidth / 2;
            const boxY = position.y - boxHeight / 2;
            
            // Determine if clickable
            const isClickable = group.context === 'daycare' || group.context.startsWith('activity_');
            
            // Create context box group with drag functionality
            const boxGroup = container.append('g')
                .attr('class', 'context-box')
                .attr('data-context-key', groupKey)
                .style('cursor', 'move');
            
            if (isClickable) {
                boxGroup.classed('clickable', true)
                    .on('click', (event) => {
                        event.stopPropagation();
                        selectContextBox(groupKey, group);
                    });
            }
            
            // Draw box background
            boxGroup.append('rect')
                .attr('x', boxX)
                .attr('y', boxY)
                .attr('width', boxWidth)
                .attr('height', boxHeight)
                .attr('rx', 12)
                .attr('ry', 12)
                .style('fill', group.color)
                .style('stroke', isClickable ? '#495057' : 'none')
                .style('stroke-width', isClickable ? 2 : 0)
                .style('stroke-dasharray', isClickable ? '5,5' : 'none')
                .style('opacity', 0.8);
            
            // Draw box label
            boxGroup.append('text')
                .attr('x', position.x)
                .attr('y', boxY + 20)
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .style('fill', '#2c3e50')
                .text(group.label);
            
            // Position and draw alters within the box
            alters.forEach((alter, i) => {
                const col = i % cols;
                const row = Math.floor(i / cols);
                const alterX = boxX + boxPadding + col * actualSpacing + actualSpacing / 2;
                const alterY = boxY + boxPadding + 30 + row * actualSpacing + actualSpacing / 2;
                
                alter.x = alterX;
                alter.y = alterY;
                
                // Ensure alter.id is normalized consistently
                alter.id = normId(alter.data.node_mapping_code) || `alter_${i}`;
                
                // Store position for edge drawing (key by normalized ID)
                if (alterPositions) {
                    alterPositions.set(alter.id, { x: alterX, y: alterY });
                }
                
                // Get node size and positioning info
                const nodeRadius = getNodeSize(alter);
                
                // Draw alter node
                const alterGroup = boxGroup.append('g')
                    .attr('class', 'alter-node')
                    .datum({
                        id: alter.id,
                        x: alterX,
                        y: alterY,
                        data: alter.data,
                        name: alter.name
                    })
                    .style('cursor', 'pointer')
                    .on('click', (event) => {
                        event.stopPropagation();
                        selectAlterNode(alter);
                    })
                    .on('mouseover', (event) => {
                        // Show tooltip with full name
                        const tooltip = document.getElementById('tooltip');
                        if (tooltip) {
                            tooltip.innerHTML = alter.name;
                            tooltip.style.left = (event.pageX + 10) + 'px';
                            tooltip.style.top = (event.pageY - 10) + 'px';
                            tooltip.style.opacity = '1';
                            tooltip.style.display = 'block';
                        }
                    })
                    .on('mouseout', () => {
                        // Hide tooltip
                        const tooltip = document.getElementById('tooltip');
                        if (tooltip) {
                            tooltip.style.opacity = '0';
                            tooltip.style.display = 'none';
                        }
                    });
  
                // Handle language pie charts when in language color mode
                if (state.ui.colorBy === 'language') {
                    const languages = normalizeLanguage(alter.data.node_language);
                    
                    if (languages.length > 1) {
                        // Create clipPath for multilingual nodes
                        const clipId = `clip-${alter.id}`;
                        const defs = alterGroup.append('defs');
                        defs.append('clipPath')
                            .attr('id', clipId)
                            .append('circle')
                            .attr('cx', alterX)
                            .attr('cy', alterY)
                            .attr('r', nodeRadius);
                        
                        // Create pie wedges
                        const pieGroup = alterGroup.append('g')
                            .attr('clip-path', `url(#${clipId})`);
                        
                        const anglePerLang = (2 * Math.PI) / languages.length;
                        languages.forEach((lang, i) => {
                            const startAngle = i * anglePerLang - Math.PI / 2; // Start from top
                            const endAngle = (i + 1) * anglePerLang - Math.PI / 2;
                            
                            const x1 = alterX + nodeRadius * Math.cos(startAngle);
                            const y1 = alterY + nodeRadius * Math.sin(startAngle);
                            const x2 = alterX + nodeRadius * Math.cos(endAngle);
                            const y2 = alterY + nodeRadius * Math.sin(endAngle);
                            
                            const largeArcFlag = anglePerLang > Math.PI ? 1 : 0;
                            const pathData = `M ${alterX} ${alterY} L ${x1} ${y1} A ${nodeRadius} ${nodeRadius} 0 ${largeArcFlag} 1 ${x2} ${y2} Z`;
                            
                            const languagePalette = {
                                'English': '#1f77b4',
                                'German': '#ff7f0e', 
                                'Spanish': '#2ca02c',
                                'Portuguese': '#d62728',
                                'Italian': '#9467bd',
                                'Thai': '#8c564b',
                                'Pre-verbal/Non-verbal': '#7f7f7f',
                                'Unknown': '#cccccc'
                            };
                            
                            pieGroup.append('path')
                                .attr('d', pathData)
                                .style('fill', languagePalette[lang] || '#cccccc')
                                .style('stroke', 'none');
                        });
                        
                        // Add stroke around the whole circle
                alterGroup.append('circle')
                    .attr('cx', alterX)
                    .attr('cy', alterY)
                            .attr('r', nodeRadius)
                            .style('fill', 'none')
                            .style('stroke', '#666666')
                    .style('stroke-width', 3);
                    } else {
                                            // Single language - regular circle
                    let nodeColor = getNodeColor(alter, 'white');
                    
                    // If this alter is selected, make it red
                    if (state.ui.selectedAlter && state.ui.selectedAlter.id === alter.id) {
                        nodeColor = '#ef4444'; // Red for selected alter
                    }
                    
                    alterGroup.append('circle')
                        .attr('cx', alterX)
                        .attr('cy', alterY)
                        .attr('r', nodeRadius)
                        .style('fill', nodeColor)
                        .style('stroke', '#666666')
                        .style('stroke-width', 3);
                    }
                } else {
                    // Regular circle for non-language modes
                    let nodeColor = state.ui.colorBy === 'context' ? 'white' : getNodeColor(alter, 'white');
                    const strokeColor = state.ui.colorBy === 'context' ? group.color : '#666666';
                    
                    // If this alter is selected, make it red
                    if (state.ui.selectedAlter && state.ui.selectedAlter.id === alter.id) {
                        nodeColor = '#ef4444'; // Red for selected alter
                    } else if (state.ui.colorBy === 'context') {
                        // Check if this alter is connected to the selected alter
                        const isConnectedToSelected = state.ui.selectedAlter && 
                            state.current.alterEdges.some(edge => 
                                (edge.source === alter.id && edge.target === state.ui.selectedAlter.id) ||
                                (edge.target === alter.id && edge.source === state.ui.selectedAlter.id)
                            );
                        
                        if (isConnectedToSelected) {
                            nodeColor = '#ffa500'; // Orange for alters connected to selected alter
                        } else {
                            nodeColor = 'white'; // White for other alters (context color)
                        }
                    }
                    
                    alterGroup.append('circle')
                        .attr('cx', alterX)
                        .attr('cy', alterY)
                        .attr('r', nodeRadius)
                        .style('fill', nodeColor)
                        .style('stroke', strokeColor)
                        .style('stroke-width', 3);
                }
                
                // Always place label inside the circle and auto-fit font size
                const labelInside = alterGroup.append('text')
                    .attr('x', alterX)
                    .attr('y', alterY)
                    .style('text-anchor', 'middle')
                    .style('dominant-baseline', 'middle')
                    .style('font-size', '13px')
                    .style('font-weight', '600')
                    .style('fill', '#2c3e50')
                    .style('pointer-events', 'auto')
                    .style('cursor', 'pointer')
                    .style('text-shadow', '0 0 3px rgba(255,255,255,0.8)')
                    .text(getAnonymizedText(alter, false))
                    .on('click', (event) => {
                        event.stopPropagation();
                        selectAlterNode(alter);
                    });
                if (typeof fitTextToCircle === 'function') { fitTextToCircle(labelInside.node(), nodeRadius); }
            });
            
            // Add drag functionality to the context box
            let initialTransform = { x: 0, y: 0 };
            
            boxGroup.call(d3.drag()
                .on('start', function(event, d) {
                    d3.select(this).style('opacity', 0.8);
                    initialTransform.x = 0;
                    initialTransform.y = 0;
                })
                .on('drag', function(event, d) {
                    // Calculate relative movement from start of drag
                    initialTransform.x += event.dx;
                    initialTransform.y += event.dy;
                    
                    // Apply transform to follow mouse smoothly
                    d3.select(this).attr('transform', `translate(${initialTransform.x}, ${initialTransform.y})`);
                    
                    // Redraw edges that connect to this context box
                    redrawContextBoxEdges();
                })
                .on('end', function(event, d) {
                    d3.select(this).style('opacity', 1);
                    
                    // Apply final displacement to position and alter data
                    const finalDx = initialTransform.x;
                    const finalDy = initialTransform.y;
                    
                    position.x += finalDx;
                    position.y += finalDy;
                    
                    group.alters.forEach(alter => {
                        alter.x += finalDx;
                        alter.y += finalDy;
                        if (alterPositions && alterPositions.has(alter.id)) {
                            const pos = alterPositions.get(alter.id);
                            alterPositions.set(alter.id, {
                                x: pos.x + finalDx,
                                y: pos.y + finalDy
                            });
                        }
                    });
                    
                    // Update data bound to DOM elements
                    d3.select(this).selectAll('.alter-node').each(function() {
                        const currentData = d3.select(this).datum();
                        if (currentData) {
                            currentData.x += finalDx;
                            currentData.y += finalDy;
                        }
                    });
                    
                    // Reset transform and apply position changes directly
                    d3.select(this).attr('transform', null);
                    
                    // Redraw context box at new permanent position
                    d3.select(this).selectAll('rect')
                        .attr('x', position.x - (boxWidth / 2))
                        .attr('y', position.y - (boxHeight / 2));
                    
                    d3.select(this).selectAll('text')
                        .attr('x', position.x)
                        .attr('y', position.y - (boxHeight / 2) + 20);
                    
                    // Update alter positions in DOM
                    d3.select(this).selectAll('.alter-node').each(function(alterData) {
                        if (alterData && typeof alterData.x === 'number' && typeof alterData.y === 'number') {
                            const alterGroup = d3.select(this);
                            alterGroup.selectAll('circle')
                                .attr('cx', alterData.x)
                                .attr('cy', alterData.y);
                            alterGroup.selectAll('text')
                                .attr('x', alterData.x)
                                .attr('y', alterData.y);
                        }
                    });
                    
                    // Final edge redraw with permanent positions
                    redrawContextBoxEdges();
                }));
        }
  
        function drawTraditionalLayout(container, ego, contextGroups, width, height) {
            // Flatten all alters and assign fixed positions
            const allAlters = [];
            Object.values(contextGroups).forEach(group => {
                group.alters.forEach(alter => {
                    alter.context = group.context;
                    alter.color = group.color;
                    allAlters.push(alter);
                });
            });
  
            // Set fixed positions for ego and alters (simple circular layout)
            ego.x = width / 2;
            ego.y = height / 2;
            
            const radius = Math.min(width, height) * 0.3;
            allAlters.forEach((alter, i) => {
                const angle = (i / allAlters.length) * 2 * Math.PI;
                alter.x = ego.x + radius * Math.cos(angle);
                alter.y = ego.y + radius * Math.sin(angle);
            });
  
            // Get the explicit layers from the container
            const backgroundLayer = container.select('.background-layer');
            const edgesLayer = container.select('.edges-layer');
            const nodesLayer = container.select('.nodes-layer');
  
            // Create ego-alter links
            const egoLinks = allAlters.map(alter => ({ source: ego, target: alter }));
            
            // Create alter-alter links from the parsed edges
            const alterLinks = state.current.alterEdges.map(edge => {
                const sourceAlter = allAlters.find(a => normId(a.data.node_mapping_code) === edge.source);
                const targetAlter = allAlters.find(a => normId(a.data.node_mapping_code) === edge.target);
                if (sourceAlter && targetAlter) {
                    return { source: sourceAlter, target: targetAlter };
                }
                return null;
            }).filter(link => link !== null);
            
            // Combine all links
            const allLinks = [...egoLinks, ...alterLinks];
            
            // Draw all links in edges layer (above background, below nodes)
            edgesLayer.selectAll('.link')
                .data(allLinks)
                .join('line')
                .attr('class', d => {
                    // Use 'alter-edge' class for alter-alter connections to enable highlighting
                    if (d.source.type !== 'ego' && d.target.type !== 'ego') {
                        return 'link alter-edge';
                    }
                    return 'link ego-edge';
                })
                .attr('data-source', d => d.source.id || d.source.name)
                .attr('data-target', d => d.target.id || d.target.name)
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y)
                .style('stroke', '#4A5568')
                .style('stroke-width', '1.5')
                .style('stroke-linecap', 'round')
                .style('opacity', '0.35');
  
            // Draw alter nodes with FULL functionality (same as grouped layout)
            allAlters.forEach((alter, i) => {
                const alterX = alter.x;
                const alterY = alter.y;
                
                // Ensure alter.id is normalized consistently
                alter.id = normId(alter.data.node_mapping_code) || `alter_${i}`;
                
                // Get node size and positioning info
                const nodeRadius = getNodeSize(alter);
                
                // Draw alter node group in nodes layer
                const alterGroup = nodesLayer.append('g')
                    .attr('class', 'alter-node')
                    .datum({
                        id: alter.id,
                        x: alterX,
                        y: alterY,
                        data: alter.data,
                        name: alter.name
                    })
                    .style('cursor', 'pointer')
                    .on('click', (event) => {
                        event.stopPropagation();
                        selectAlterNode(alter);
                    })
                    .on('mouseover', (event) => {
                        // Show tooltip with full name
                        const tooltip = document.getElementById('tooltip');
                        if (tooltip) {
                            tooltip.innerHTML = alter.name;
                            tooltip.style.left = (event.pageX + 10) + 'px';
                            tooltip.style.top = (event.pageY - 10) + 'px';
                            tooltip.style.opacity = '1';
                            tooltip.style.display = 'block';
                        }
                    })
                    .on('mouseout', () => {
                        // Hide tooltip
                        const tooltip = document.getElementById('tooltip');
                        if (tooltip) {
                            tooltip.style.opacity = '0';
                            tooltip.style.display = 'none';
                        }
                    });
  
                // Handle pie charts for multilingual nodes OR multi-race nodes
                let shouldDrawPieChart = false;
                let pieData = [];
                let piePalette = {};
                
                if (state.ui.colorBy === 'language') {
                    const languages = normalizeLanguage(alter.data.node_language);
                    if (languages.length > 1) {
                        shouldDrawPieChart = true;
                        pieData = languages;
                        piePalette = {
                            'English': '#1f77b4',
                            'German': '#ff7f0e', 
                            'Spanish': '#2ca02c',
                            'Portuguese': '#d62728',
                            'Italian': '#9467bd',
                            'Thai': '#8c564b',
                            'Pre-verbal/Non-verbal': '#7f7f7f',
                            'Unknown': '#cccccc'
                        };
                    }
                } else if (state.ui.colorBy === 'race') {
                    const races = normalizeRace(alter.data.node_race);
                    if (races.length > 1) {
                        shouldDrawPieChart = true;
                        pieData = races;
                        piePalette = {
                            'White': '#76b7b2',
                            'Black': '#59a14f',
                            'Hispanic/Latino': '#edc949',
                            'Asian': '#af7aa1',
                            'Native/Alaska': '#8dd3c7',
                            'MENA': '#fb8072',
                            'Multiracial': '#bc80bd',
                            'Other': '#d9d9d9'
                        };
                    }
                }
                
                if (shouldDrawPieChart) {
                    // Create clipPath for pie chart nodes
                    const clipId = `clip-${alter.id}`;
                    const defs = alterGroup.append('defs');
                    defs.append('clipPath')
                        .attr('id', clipId)
                        .append('circle')
                        .attr('cx', alterX)
                        .attr('cy', alterY)
                        .attr('r', nodeRadius);
                    
                    // Create pie wedges
                    const pieGroup = alterGroup.append('g')
                        .attr('clip-path', `url(#${clipId})`);
                    
                    const anglePerSlice = (2 * Math.PI) / pieData.length;
                    pieData.forEach((item, i) => {
                        const startAngle = i * anglePerSlice - Math.PI / 2; // Start from top
                        const endAngle = (i + 1) * anglePerSlice - Math.PI / 2;
                        
                        const x1 = alterX + nodeRadius * Math.cos(startAngle);
                        const y1 = alterY + nodeRadius * Math.sin(startAngle);
                        const x2 = alterX + nodeRadius * Math.cos(endAngle);
                        const y2 = alterY + nodeRadius * Math.sin(endAngle);
                        
                        const largeArcFlag = anglePerSlice > Math.PI ? 1 : 0;
                        const pathData = `M ${alterX} ${alterY} L ${x1} ${y1} A ${nodeRadius} ${nodeRadius} 0 ${largeArcFlag} 1 ${x2} ${y2} Z`;
                        
                        pieGroup.append('path')
                            .attr('d', pathData)
                            .style('fill', piePalette[item] || '#cccccc')
                            .style('stroke', 'none');
                    });
                    
                    // Add stroke around the whole circle
                    alterGroup.append('circle')
                        .attr('cx', alterX)
                        .attr('cy', alterY)
                        .attr('r', nodeRadius)
                        .style('fill', 'none')
                        .style('stroke', '#666666')
                        .style('stroke-width', 3);
                } else {
                    // Regular circle for single values or other color modes
                    let nodeColor = state.ui.colorBy === 'context' ? 'white' : getNodeColor(alter, 'white');
                    const strokeColor = state.ui.colorBy === 'context' ? alter.color : '#666666';
                    
                    // If this alter is selected, make it red
                    if (state.ui.selectedAlter && state.ui.selectedAlter.id === alter.id) {
                        nodeColor = '#ef4444'; // Red for selected alter
                    } else if (state.ui.colorBy === 'context') {
                        // Check if this alter is connected to the selected alter
                        const isConnectedToSelected = state.ui.selectedAlter && 
                            state.current.alterEdges.some(edge => 
                                (edge.source === alter.id && edge.target === state.ui.selectedAlter.id) ||
                                (edge.target === alter.id && edge.source === state.ui.selectedAlter.id)
                            );
                        
                        if (isConnectedToSelected) {
                            nodeColor = '#ffa500'; // Orange for alters connected to selected alter
                        } else {
                            nodeColor = 'white'; // White for other alters (context color)
                        }
                    }
                    
                    alterGroup.append('circle')
                        .attr('cx', alterX)
                        .attr('cy', alterY)
                        .attr('r', nodeRadius)
                        .style('fill', nodeColor)
                        .style('stroke', strokeColor)
                        .style('stroke-width', 3);
                }
                
                // Always place label inside the circle and auto-fit font size
                const labelInside2 = alterGroup.append('text')
                    .attr('x', alterX)
                    .attr('y', alterY)
                    .style('text-anchor', 'middle')
                    .style('dominant-baseline', 'middle')
                    .style('font-size', '13px')
                    .style('font-weight', '600')
                    .style('fill', '#2c3e50')
                    .style('pointer-events', 'auto')
                    .style('cursor', 'pointer')
                    .style('text-shadow', '0 0 3px rgba(255,255,255,0.8)')
                    .text(getAnonymizedText(alter, false))
                    .on('click', (event) => {
                        event.stopPropagation();
                        selectAlterNode(alter);
                    });
                if (typeof fitTextToCircle === 'function') { fitTextToCircle(labelInside2.node(), nodeRadius); }
  
                // Add metric under name based on sizing mode
                if (state.ui.nodeSizeBy === 'weekly_hours') {
                    const weeklyHours = parseFloat(alter.data.node_weekly_hour_summarized || alter.data.node_weekly_hour || 0);
                    alterGroup.append('text')
                        .attr('x', alterX)
                        .attr('y', alterY + 8)
                        .style('text-anchor', 'middle')
                        .style('dominant-baseline', 'middle')
                        .style('font-size', '8px')
                        .style('font-weight', '400')
                        .style('fill', '#6c757d')
                        .style('pointer-events', 'none')
                        .text(`${weeklyHours}h`);
                } else if (state.ui.nodeSizeBy === 'closeness') {
                    const closeness = parseFloat(alter.data.node_closeness_score || 0);
                    alterGroup.append('text')
                        .attr('x', alterX)
                        .attr('y', alterY + 8)
                        .style('text-anchor', 'middle')
                        .style('dominant-baseline', 'middle')
                        .style('font-size', '8px')
                        .style('font-weight', '400')
                        .style('fill', '#6c757d')
                        .style('pointer-events', 'none')
                        .text(`${Math.round(isNaN(closeness) ? 0 : closeness)}`);
                } else if (state.ui.nodeSizeBy === 'closeness_intensity_z') {
                    const zScore = getClosenessIntensityZFromData(alter.data);
                    alterGroup.append('text')
                        .attr('x', alterX)
                        .attr('y', alterY + 8)
                        .style('text-anchor', 'middle')
                        .style('dominant-baseline', 'middle')
                        .style('font-size', '8px')
                        .style('font-weight', '400')
                        .style('fill', '#6c757d')
                        .style('pointer-events', 'none')
                        .text(zScore.toFixed(2));
                }
  
  
  
                // Add survey respondent indicator if applicable
                if (isShowingRespondent(alter)) {
                    alterGroup.classed('survey-respondent', true);
                }
            });
  
            // Draw distinctive ego node in nodes layer
            const egoGroup = nodesLayer.append('g')
                .attr('class', 'ego-node')
                .datum({
                    id: 'ego',
                    x: ego.x,
                    y: ego.y,
                    data: ego,
                    name: ego.name,
                    type: 'ego'
                })
                .style('cursor', 'pointer')
                .on('click', showEgoInfo);
            
            const size = 30;
            const rx = size * 0.3;
            
            egoGroup.append('rect')
                .attr('x', ego.x - size)
                .attr('y', ego.y - size)
                .attr('width', size * 2)
                .attr('height', size * 2)
                .attr('rx', rx)
                .attr('ry', rx)
                .style('fill', getEgoColor())
                .style('stroke', 'white')
                .style('stroke-width', 3);
  
            // Add ego label
            egoGroup.append('text')
                .attr('x', ego.x)
                .attr('y', ego.y)
                .style('text-anchor', 'middle')
                .style('dominant-baseline', 'middle')
                .style('font-size', '12px')
                .style('font-weight', 'bold')
                .style('fill', 'white')
                .style('pointer-events', 'none')
                .text(truncateName(getAnonymizedText(ego, true), 30));
        }
  
        function drawEgoNode(container, ego) {
            const egoGroup = container.append('g')
                .attr('class', 'ego-node')
                .datum({
                    id: 'ego',
                    x: ego.x,
                    y: ego.y,
                    data: ego,
                    name: ego.name,
                    type: 'ego'
                })
                .style('cursor', 'pointer')
                .on('click', showEgoInfo);
            
            const size = 30;
            const rx = size * 0.3;
            const childData = state.current.childData;
            
            // Check if ego should have pie chart for multiple languages or races
            let shouldDrawPieChart = false;
            let pieData = [];
            let piePalette = {};
            
            if (childData && state.ui.colorBy === 'language') {
                const languages = normalizeLanguage(childData.child_lang);
                if (languages.length > 1) {
                    shouldDrawPieChart = true;
                    pieData = languages;
                    piePalette = {
                        'English': '#1f77b4',
                        'German': '#ff7f0e', 
                        'Spanish': '#2ca02c',
                        'Portuguese': '#d62728',
                        'Italian': '#9467bd',
                        'Thai': '#8c564b',
                        'Chinese': '#ff69b4',
                        'Chinese (Cantonese)': '#ff69b4',
                        'Chinese (Mandarin)': '#ff1493',
                        'French': '#32cd32',
                        'Japanese': '#ff4500',
                        'Korean': '#9932cc',
                        'Arabic': '#20b2aa',
                        'Hindi': '#ff6347',
                        'Russian': '#4169e1',
                        'Dutch': '#ff8c00',
                        'Swedish': '#00ced1',
                        'Norwegian': '#da70d6',
                        'Danish': '#ffd700',
                        'Finnish': '#00fa9a',
                        'Polish': '#dc143c',
                        'Czech': '#8b008b',
                        'Hungarian': '#b8860b',
                        'Greek': '#2e8b57',
                        'Turkish': '#cd853f',
                        'Hebrew': '#ff69b4',
                        'Persian': '#ff4500',
                        'Vietnamese': '#32cd32',
                        'Filipino': '#9932cc',
                        'Indonesian': '#20b2aa',
                        'Malay': '#ff6347',
                        'Pre-verbal/Non-verbal': '#7f7f7f',
                        'Unknown': '#cccccc'
                    };
                }
            } else if (childData && state.ui.colorBy === 'race') {
                const races = normalizeRace(childData.child_race);
                if (races.length > 1) {
                    shouldDrawPieChart = true;
                    pieData = races;
                    piePalette = {
                        'White': '#76b7b2',
                        'Black': '#59a14f',
                        'Hispanic/Latino': '#edc949',
                        'Asian': '#af7aa1',
                        'Native/Alaska': '#8dd3c7',
                        'MENA': '#fb8072',
                        'Multiracial': '#bc80bd',
                        'Other': '#d9d9d9'
                    };
                }
            }
            
            if (shouldDrawPieChart) {
                // Create clipPath for pie chart in square shape
                const clipId = `clip-ego`;
                const defs = egoGroup.append('defs');
                defs.append('clipPath')
                    .attr('id', clipId)
                    .append('rect')
                    .attr('x', ego.x - size)
                    .attr('y', ego.y - size)
                    .attr('width', size * 2)
                    .attr('height', size * 2)
                    .attr('rx', rx)
                    .attr('ry', rx);
                
                // Create pie wedges within the clipped square
                const pieGroup = egoGroup.append('g')
                    .attr('clip-path', `url(#${clipId})`);
                
                const radius = size * 1.2; // Larger radius to fill the square
                const anglePerSlice = (2 * Math.PI) / pieData.length;
                
                pieData.forEach((item, i) => {
                    const startAngle = i * anglePerSlice - Math.PI / 2; // Start from top
                    const endAngle = (i + 1) * anglePerSlice - Math.PI / 2;
                    
                    const x1 = ego.x + radius * Math.cos(startAngle);
                    const y1 = ego.y + radius * Math.sin(startAngle);
                    const x2 = ego.x + radius * Math.cos(endAngle);
                    const y2 = ego.y + radius * Math.sin(endAngle);
                    
                    const largeArcFlag = anglePerSlice > Math.PI ? 1 : 0;
                    const pathData = `M ${ego.x} ${ego.y} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2} Z`;
                    
                    pieGroup.append('path')
                        .attr('d', pathData)
                        .style('fill', piePalette[item] || '#cccccc')
                        .style('stroke', 'none');
                });
                
                // Add stroke around the whole square
                egoGroup.append('rect')
                    .attr('x', ego.x - size)
                    .attr('y', ego.y - size)
                    .attr('width', size * 2)
                    .attr('height', size * 2)
                    .attr('rx', rx)
                    .attr('ry', rx)
                    .style('fill', 'none')
                    .style('stroke', 'white')
                    .style('stroke-width', 3);
            } else {
                // Regular solid-colored square for single values or other color modes
                egoGroup.append('rect')
                    .attr('x', ego.x - size)
                    .attr('y', ego.y - size)
                    .attr('width', size * 2)
                    .attr('height', size * 2)
                    .attr('rx', rx)
                    .attr('ry', rx)
                    .style('fill', getEgoColor())
                    .style('stroke', 'white')
                    .style('stroke-width', 3);
            }
            
            egoGroup.append('text')
                .attr('x', ego.x)
                .attr('y', ego.y)
                .style('text-anchor', 'middle')
                .style('dominant-baseline', 'middle')
                .style('font-size', '12px')
                .style('font-weight', 'bold')
                .style('fill', 'white')
                .style('pointer-events', 'none')
                .text(truncateName(getAnonymizedText(ego, true), 30));
        }
  
        function showHelp() {
            document.getElementById('helpOverlay').style.display = 'block';
        }
  
        function hideHelp() {
            document.getElementById('helpOverlay').style.display = 'none';
        }
  
        function getNodeColor(node, defaultColor) {
            if (state.ui.colorBy === 'context') {
                return defaultColor;
            }
            
            const colorPalettes = {
                gender: {
                    'Male': '#4e79a7',
                    'Female': '#f28e2c',
                    'Other': '#e15759'
                },
                race: {
                    'White': '#76b7b2',
                    'Black': '#59a14f',
                    'Hispanic/Latino': '#edc949',
                    'Asian': '#af7aa1',
                    'Native/Alaska': '#8dd3c7',
                    'MENA': '#fb8072',
                    'Multiracial': '#bc80bd',
                    'Other': '#d9d9d9'
                },
                language: {
                    'English': '#1f77b4',
                    'German': '#ff7f0e', 
                    'Spanish': '#2ca02c',
                    'Portuguese': '#d62728',
                    'Italian': '#9467bd',
                    'Thai': '#8c564b',
                    'Pre-verbal/Non-verbal': '#7f7f7f',
                    'Unknown': '#cccccc'
                },
                kin: {
                    'Yes': '#E53935',
                    'No': '#9CA3AF'
                },
                weekly_hours: {
                    '≤3h': '#d1f2eb',      // Very light green
                    '3-10h': '#7fb3d3',    // Light blue  
                    '11-30h': '#5dade2',   // Medium blue
                    '30-60h': '#3498db',   // Blue
                    '>60h': '#2874a6'      // Dark blue
                }
            };
            
            // Check if this is an ego node and get child data
            let value;
            if (node.isEgo || node.type === 'ego') {
                // For ego nodes, get data from child data
                const childData = state.current.childData;
                if (childData) {
                    if (state.ui.colorBy === 'gender') {
                        value = childData.child_gender;
                    } else if (state.ui.colorBy === 'race') {
                        value = childData.child_race;
                    } else if (state.ui.colorBy === 'language') {
                        value = childData.child_lang;
                    } else if (state.ui.colorBy === 'kin') {
                        value = 'N/A'; // Ego is always self, not kin
                    } else if (state.ui.colorBy === 'weekly_hours') {
                        value = 0; // Ego typically doesn't have weekly hours, so use 0 (≤3h category)
                    }
                }
            } else {
                // For alter nodes, get data from node data
                if (state.ui.colorBy === 'weekly_hours') {
                    value = node.data.node_weekly_hour_summarized || node.data.node_weekly_hour;
                } else {
                    value = node.data[`node_${state.ui.colorBy}`];
                }
            }
            
            const palette = colorPalettes[state.ui.colorBy];
            
            // Special handling for different modes
            if (state.ui.colorBy === 'language') {
                const languages = normalizeLanguage(value);
                if (languages.length > 0) {
                    const firstLang = languages[0];
                    return palette[firstLang] || '#cccccc';
                }
                return '#cccccc';
            } else if (state.ui.colorBy === 'race') {
                const canonicalRace = canonRace(value);
                return palette[canonicalRace] || '#cccccc';
            } else if (state.ui.colorBy === 'kin') {
                const canonicalKin = canonKin(value);
                return palette[canonicalKin] || '#cccccc';
            } else if (state.ui.colorBy === 'weekly_hours') {
                // Get weekly hours value and categorize it
                const hours = parseFloat(value || 0);
                let category;
                if (hours <= 3) {
                    category = '≤3h';
                } else if (hours <= 10) {
                    category = '3-10h';
                } else if (hours <= 30) {
                    category = '11-30h';
                } else if (hours <= 60) {
                    category = '30-60h';
                } else {
                    category = '>60h';
                }
                return palette[category] || '#cccccc';
            }
            
            return palette && palette[value] ? palette[value] : '#cccccc';
        }
  
        function getEgoColor() {
            // Default teal color for context mode or when no child data
            if (state.ui.colorBy === 'context' || !state.current.childData) {
                return '#14b8a6';
            }
            
            const colorPalettes = {
                gender: {
                    'Male': '#4e79a7',
                    'Female': '#f28e2c',
                    'Other': '#e15759'
                },
                race: {
                    'White': '#76b7b2',
                    'Black': '#59a14f',
                    'Hispanic/Latino': '#edc949',
                    'Asian': '#af7aa1',
                    'Native/Alaska': '#8dd3c7',
                    'MENA': '#fb8072',
                    'Multiracial': '#bc80bd',
                    'Other': '#d9d9d9'
                },
                language: {
                    'English': '#1f77b4',
                    'German': '#ff7f0e', 
                    'Spanish': '#2ca02c',
                    'Portuguese': '#d62728',
                    'Italian': '#9467bd',
                    'Thai': '#8c564b',
                    'Pre-verbal/Non-verbal': '#7f7f7f',
                    'Unknown': '#cccccc'
                },
                kin: {
                    'Yes': '#E53935',
                    'No': '#9CA3AF'
                },
                weekly_hours: {
                    '≤3h': '#d1f2eb',      // Very light green
                    '3-10h': '#7fb3d3',    // Light blue  
                    '11-30h': '#5dade2',   // Medium blue
                    '30-60h': '#3498db',   // Blue
                    '>60h': '#2874a6'      // Dark blue
                }
            };
            
            const childData = state.current.childData;
            let value;
            
            if (state.ui.colorBy === 'gender') {
                value = childData.child_gender;
            } else if (state.ui.colorBy === 'race') {
                value = childData.child_race;
            } else if (state.ui.colorBy === 'language') {
                value = childData.child_lang;
            } else if (state.ui.colorBy === 'kin') {
                value = 'No'; // Ego is never kin to themselves
            } else if (state.ui.colorBy === 'weekly_hours') {
                value = 0; // Ego typically doesn't have weekly hours, so use 0 (≤3h category)
            }
            
            const palette = colorPalettes[state.ui.colorBy];
            
            // Special handling for different modes
            if (state.ui.colorBy === 'language') {
                const languages = normalizeLanguage(value);
                if (languages.length > 0) {
                    const firstLang = languages[0];
                    return palette[firstLang] || '#cccccc';
                }
                return '#cccccc';
            } else if (state.ui.colorBy === 'race') {
                const canonicalRace = canonRace(value);
                return palette[canonicalRace] || '#cccccc';
            } else if (state.ui.colorBy === 'kin') {
                const canonicalKin = canonKin(value);
                return palette[canonicalKin] || '#cccccc';
            } else if (state.ui.colorBy === 'weekly_hours') {
                // Categorize weekly hours value
                const hours = parseFloat(value || 0);
                let category;
                if (hours <= 3) {
                    category = '≤3h';
                } else if (hours <= 10) {
                    category = '3-10h';
                } else if (hours <= 30) {
                    category = '11-30h';
                } else if (hours <= 60) {
                    category = '30-60h';
                } else {
                    category = '>60h';
                }
                return palette[category] || '#cccccc';
            }
            
            return palette && palette[value] ? palette[value] : '#cccccc';
        }
  
        function calculateQuantileBuckets(values, buckets = 5) {
            const sorted = values.filter(v => !isNaN(v) && v !== null && v !== undefined).sort((a, b) => a - b);
            if (sorted.length === 0) return [];
            
            const quantiles = [];
            for (let i = 1; i <= buckets; i++) {
                const index = Math.ceil((i / buckets) * sorted.length) - 1;
                quantiles.push(sorted[Math.min(index, sorted.length - 1)]);
            }
            return quantiles;
        }
  
        function getNodeSizeFromValue(value, quantiles, sizes = [35, 40, 45, 50, 55]) {
            if (!quantiles || quantiles.length === 0) return sizes[0];
            
            for (let i = 0; i < quantiles.length; i++) {
                if (value <= quantiles[i]) {
                    return sizes[i] || sizes[sizes.length - 1];
                }
            }
            return sizes[sizes.length - 1];
        }
  
        function getNodeSize(node) {
            const minSize = 35;
            
            if (state.ui.nodeSizeBy === 'weekly_hours') {
                const hours = parseFloat(node.data?.node_weekly_hour_summarized || node.data?.node_weekly_hour || 0);
                
                if (!state.current.hourQuantiles) {
                    const allHours = state.current.alterData.map(d => 
                        parseFloat(d.node_weekly_hour_summarized || d.node_weekly_hour || 0)
                    );
                    state.current.hourQuantiles = calculateQuantileBuckets(allHours);
                }
                
                return Math.max(minSize, getNodeSizeFromValue(hours, state.current.hourQuantiles));
            } else if (state.ui.nodeSizeBy === 'closeness') {
                const closeness = parseFloat(node.data?.node_closeness_score || 0);
                // Discrete buckets: 0,1,2,3,4
                const sizesFixed = [35, 40, 45, 50, 55];
                if (isNaN(closeness)) return sizesFixed[0];
                const idx = Math.max(0, Math.min(4, Math.round(closeness)));
                return sizesFixed[idx];
            } else if (state.ui.nodeSizeBy === 'closeness_intensity_z') {
                const closenessIntensity = getClosenessIntensityZFromData(node.data);
                
                if (!state.current.closenessIntensityQuantiles) {
                    const allClosenessIntensity = state.current.alterData.map(d => 
                        getClosenessIntensityZFromData(d)
                    );
                    state.current.closenessIntensityQuantiles = calculateQuantileBuckets(allClosenessIntensity);
                }
                
                return Math.max(minSize, getNodeSizeFromValue(closenessIntensity, state.current.closenessIntensityQuantiles));
            }
            return minSize;
        }
  
        function updateSizeLegend() {
            const sizeLegendSection = document.getElementById('sizeLegendSection');
            const sizeLegendTitle = document.getElementById('sizeLegendTitle');
            const sizeLegendItems = document.getElementById('sizeLegendItems');
            
            // Add null checks to prevent errors
            if (!sizeLegendSection || !sizeLegendTitle || !sizeLegendItems) {
                console.log('Size legend elements not found, skipping update');
                return;
            }
            
            if (state.ui.nodeSizeBy === 'default') {
                sizeLegendSection.style.display = 'none';
                return;
            }
            
            sizeLegendSection.style.display = 'block';
            const sizeLabels = {
                'weekly_hours': 'Node Size: Weekly Hours',
                'closeness': 'Node Size: Closeness Score',
                'closeness_intensity_z': 'Node Size: Closeness Intensity Z-Score'
            };
            sizeLegendTitle.textContent = sizeLabels[state.ui.nodeSizeBy] || 'Node Size';
            
            let legendItems = '';
            const sizes = [35, 40, 45, 50, 55];
            
            if (state.ui.nodeSizeBy === 'weekly_hours' && state.current.hourQuantiles) {
                const quantiles = state.current.hourQuantiles;
                let prevValue = 0;
                
                quantiles.forEach((quantile, i) => {
                    const rangeLabel = i === 0 ? `≤${quantile}h` : 
                                     i === quantiles.length - 1 ? `>${prevValue}h` :
                                     `${prevValue + 0.1}-${quantile}h`;
                    
                    legendItems += `
                        <div class="size-legend-item">
                            <div class="size-circle" style="width: ${sizes[i] * 2}px; height: ${sizes[i] * 2}px;"></div>
                            <span>${rangeLabel}</span>
                        </div>
                    `;
                    prevValue = quantile;
                });
            } else if (state.ui.nodeSizeBy === 'closeness') {
                const buckets = ['0','1','2','3','4'];
                buckets.forEach((label, i) => {
                    legendItems += `
                        <div class="size-legend-item">
                            <div class="size-circle" style="width: ${sizes[i] * 2}px; height: ${sizes[i] * 2}px;"></div>
                            <span>${label}</span>
                        </div>
                    `;
                });
            } else if (state.ui.nodeSizeBy === 'closeness_intensity_z' && state.current.closenessIntensityQuantiles) {
                const quantiles = state.current.closenessIntensityQuantiles;
                let prevValue = -Infinity;
                
                quantiles.forEach((quantile, i) => {
                    const rangeLabel = i === 0 ? `≤${quantile.toFixed(2)}` : 
                                     i === quantiles.length - 1 ? `>${prevValue.toFixed(2)}` :
                                     `${prevValue.toFixed(2)}-${quantile.toFixed(2)}`;
                    
                    legendItems += `
                        <div class="size-legend-item">
                            <div class="size-circle" style="width: ${sizes[i] * 2}px; height: ${sizes[i] * 2}px;"></div>
                            <span>${rangeLabel}</span>
                        </div>
                    `;
                    prevValue = quantile;
                });
            }
            
            if (legendItems) {
                sizeLegendItems.innerHTML = legendItems;
                sizeLegendSection.style.display = 'block';
            } else {
                sizeLegendSection.style.display = 'none';
            }
        }
  
        function truncateName(name, radius) {
            const maxChars = Math.floor(radius / 4);
            return name.length > maxChars ? name.slice(0, maxChars - 1) + '…' : name;
        }
  
        function updateLegend() {
            const colorLegendTitle = document.getElementById('colorLegendTitle');
            const colorLegendItems = document.getElementById('colorLegendItems');
            
            // Add null checks to prevent errors
            if (!colorLegendTitle || !colorLegendItems) {
                console.log('Color legend elements not found, skipping update');
                return;
            }
            
            // Update legend title based on color mode
            const colorModeMap = {
                'context': 'Color by: Context',
                'gender': 'Color by: Gender', 
                'race': 'Color by: Race',
                'language': 'Color by: Language',
                'kin': 'Color by: Kin'
            };
            colorLegendTitle.textContent = colorModeMap[state.ui.colorBy] || 'Color by: Context';
            
            colorLegendItems.innerHTML = '';
  
            // Add ego
            const egoItem = document.createElement('div');
            egoItem.className = 'legend-item';
            egoItem.innerHTML = `
                <div style="width: 16px; height: 16px; background: #14b8a6; border-radius: 3px; border: 1px solid rgba(0,0,0,0.2);"></div>
                <span>Child (Ego)</span>
            `;
            colorLegendItems.appendChild(egoItem);
  
            if (state.ui.colorBy === 'context') {
                // Add context colors
                const activeContexts = new Set();
                
                // Find active activity contexts
                if (state.current.alterData) {
                    state.current.alterData.forEach(alter => {
                        const context = canonContext(alter.node_type);
                        activeContexts.add(context);
                    });
                }
  
                // Add base contexts that are visible
            Object.entries(CONTEXTS).forEach(([key, config]) => {
                    if (state.ui.visibleContexts.has(key) && activeContexts.has(key)) {
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    item.innerHTML = `
                        <div class="legend-color" style="background: ${config.color};"></div>
                        <span>${config.label}</span>
                    `;
                        colorLegendItems.appendChild(item);
                    }
                });
  
                // Add specific activity contexts
                Array.from(activeContexts).filter(ctx => ctx.startsWith('activity_')).forEach(activityContext => {
                    const activityId = activityContext.split('_')[1];
                    const activityData = state.data.activityIndex[state.current.child]?.[activityId];
                    const activityLabel = `Activity ${activityId}${activityData?.activity_name ? ': ' + activityData.activity_name : ''}`;
                    const color = getContextColor(activityContext);
  
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    item.innerHTML = `
                        <div class="legend-color" style="background: ${color};"></div>
                        <span>${activityLabel}</span>
                    `;
                    colorLegendItems.appendChild(item);
                });
            } else {
                // Color by demographic - show categories with counts
                const categories = new Map();
                
                if (state.current.alterData) {
                    const filteredData = applyFilters(state.current.alterData);
                    
                    filteredData.forEach(alter => {
                        if (state.ui.colorBy === 'language') {
                            // Handle multilingual nodes
                            const languages = normalizeLanguage(alter.node_language);
                            languages.forEach(lang => {
                                categories.set(lang, (categories.get(lang) || 0) + 1);
                            });
                        } else if (state.ui.colorBy === 'race') {
                            const canonicalRace = canonRace(alter.node_race);
                            categories.set(canonicalRace, (categories.get(canonicalRace) || 0) + 1);
                        } else if (state.ui.colorBy === 'kin') {
                            const canonicalKin = canonKin(alter.node_kin);
                            categories.set(canonicalKin, (categories.get(canonicalKin) || 0) + 1);
                        } else {
                            const value = alter[`node_${state.ui.colorBy}`] || '?';
                            categories.set(value, (categories.get(value) || 0) + 1);
                        }
                    });
                }
  
                const colorPalettes = {
                    gender: {
                        'Male': '#4e79a7',
                        'Female': '#f28e2c',
                        'Other': '#e15759'
                    },
                    race: {
                        'White': '#76b7b2',
                        'Black': '#59a14f',
                        'Hispanic/Latino': '#edc949',
                        'Asian': '#af7aa1',
                        'Native/Alaska': '#8dd3c7',
                        'MENA': '#fb8072',
                        'Multiracial': '#bc80bd',
                        'Other': '#d9d9d9'
                    },
                    language: {
                        'English': '#1f77b4',
                        'German': '#ff7f0e', 
                        'Spanish': '#2ca02c',
                        'Portuguese': '#d62728',
                        'Italian': '#9467bd',
                        'Thai': '#8c564b',
                        'Pre-verbal/Non-verbal': '#7f7f7f',
                        'Unknown': '#cccccc'
                    },
                    kin: {
                        'Yes': '#E53935',
                        'No': '#9CA3AF'
                    }
                };
  
                const palette = colorPalettes[state.ui.colorBy] || {};
                
                categories.forEach((count, value) => {
                    const color = palette[value] || '#cccccc';
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    item.innerHTML = `
                        <div class="legend-color" style="background: ${color};"></div>
                        <span>${value} (${count})</span>
                    `;
                    colorLegendItems.appendChild(item);
                });
            }
        }
  
        function showContextInfo(groupKey, group) {
            const panel = document.getElementById('contextPanel');
            const title = document.getElementById('contextTitle');
            const content = document.getElementById('contextContent');
            
            title.textContent = `${group.label} Information`;
            
            let contextDetails = '';
            
            if (group.context === 'daycare') {
                const childData = state.current.childData;
                if (childData) {
                    contextDetails = `
                        <div class="info-row">
                            <span class="info-label">Childcare Type:</span>
                            <span class="info-value">${formatChildcareType(childData.childcare_type)}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Start Age:</span>
                            <span class="info-value">${childData.childcare_start_age ? Math.round(parseFloat(childData.childcare_start_age)) : 'N/A'} months</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Group Size:</span>
                            <span class="info-value">${childData.childcare_size ? Math.round(parseFloat(childData.childcare_size)) : 'N/A'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Child Gender:</span>
                            <span class="info-value">${childData.child_gender || 'N/A'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Child Race:</span>
                            <span class="info-value">${childData.child_race || 'N/A'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Child Language:</span>
                            <span class="info-value">${childData.child_lang || 'N/A'}</span>
                        </div>
                    `;
                }
            } else if (group.context.startsWith('activity_')) {
                const activityId = group.context.split('_')[1];
                const activityData = state.data.activityIndex[state.current.child]?.[activityId];
                const childData = state.current.childData;
                
                if (activityData) {
                    contextDetails = `
                        <div class="info-row">
                            <span class="info-label">Activity Name:</span>
                            <span class="info-value">${activityData.activity_name || 'N/A'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Other Kids:</span>
                            <span class="info-value">${activityData.activity_otherkids_yn || 'N/A'}</span>
                        </div>
                        ${activityData.activity_otherkids_yn === 'Yes' ? `
                        <div class="info-row">
                            <span class="info-label"># Other Kids:</span>
                            <span class="info-value">${activityData.activity_otherkids_n || 'N/A'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Age Group:</span>
                            <span class="info-value">${activityData.activity_kids || 'N/A'}</span>
                        </div>
                        ` : ''}
                        <div class="info-row">
                            <span class="info-label">Child Gender:</span>
                            <span class="info-value">${activityData.activity_gender || childData?.child_gender || 'N/A'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Child Race:</span>
                            <span class="info-value">${activityData.activity_race || childData?.child_race || 'N/A'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Language Used:</span>
                            <span class="info-value">${activityData.activity_lang || childData?.child_lang || 'N/A'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Adults in Activity:</span>
                            <span class="info-value">${activityData.activity_adults || 'N/A'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Kids in Activity:</span>
                            <span class="info-value">${activityData.activity_kids || 'N/A'}</span>
                        </div>
                    `;
                }
            }
            
            // List of alters in this context
            const alterList = group.alters.map(alter => {
                const role = alter.data.node_relationship || alter.data.node_type || 'Unknown';
                return `<div style="margin: 0.25rem 0;">${alter.name} (${role})</div>`;
            }).join('');
            
            content.innerHTML = `
                <div class="info-row">
                    <span class="info-label">Context:</span>
                    <span class="info-value">${group.label}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Number of Alters:</span>
                    <span class="info-value">${group.alters.length}</span>
                </div>
                ${contextDetails}
                <div style="margin-top: 1.5rem; border-top: 2px solid #e9ecef; padding-top: 1rem;">
                    <div style="font-weight: 600; margin-bottom: 0.75rem; color: #495057;">Alters in this Context:</div>
                    ${alterList}
                </div>
            `;
            
            showPanel(panel);
        }
  
        function selectAlterNode(alter) {
            console.log('Selecting alter:', alter.id, alter.data?.node_name);
            
            // Set selection state
            state.ui.selectedAlter = alter;
            state.ui.selectedContext = null;
            state.ui.detailsType = 'alter';
            
            // Hide hover tooltip immediately on click
            const tooltip = document.getElementById('tooltip');
            if (tooltip) { tooltip.style.opacity = '0'; tooltip.style.display = 'none'; }
            
            // Redraw edges to reflect current visibility setting
            if (state.current.alterEdges && state.current.alterEdges.length > 0) {
                redrawAlterEdges();
            }
            
            // Update visual highlighting with exact colors
            updateNodeSelection();
            
            // Show resizable details panel with alter info
            showResizableDetails(alter);
        }
  
        function selectAlter(alter) {
            selectAlterNode(alter);
        }
  
        function selectContextBox(groupKey, group) {
            // Clear alter selection and set context selection
            state.ui.selectedAlter = null;
            state.ui.selectedContext = { groupKey, group };
            state.ui.detailsType = 'context';
            
            // Clear visual highlighting
            clearVisualSelection();
            
            // Show unified details card with context info
            showUnifiedDetails('context', { groupKey, group });
        }
  
        function clearSelection() {
            state.ui.selectedAlter = null;
            state.ui.selectedContext = null;
            state.ui.detailsType = null;
            document.getElementById('unifiedDetailsCard').style.display = 'none';
            document.getElementById('fixedDetailsPanel').style.display = 'none';
            document.getElementById('alterDetailsSection').style.display = 'none';
            
            clearVisualSelection();
        }
  
        function clearVisualSelection() {
            console.log('Clearing visual selection...');
            
            // Reset all nodes to normal state by removing CSS classes
            const nodeCount = d3.selectAll('.alter-node')
                .classed('node--selected', false)
                .classed('node--neighbor', false)
                .size();
            
            // Reset ALL edges to default styling by removing CSS classes
            const edgeCount = d3.selectAll('.alter-edge')
                .classed('edge--active', false)
                .size();
            
            // Only clear edge styles if we're not in "all ties" mode
            // This ensures edges remain visible when Edge Visibility is set to "All ties (default)"
            if (state.ui.edgeVisibility !== 'all') {
                d3.selectAll('.alter-edge')
                    .style('stroke', null)
                    .style('stroke-width', null)
                    .style('opacity', null);
            } else {
                // In "all ties" mode, restore default edge styling
                d3.selectAll('.alter-edge').each(function() {
                    const element = d3.select(this);
                    element.style('stroke', '#4A5568')
                          .style('stroke-width', '1.5px')
                          .style('opacity', '0.35');
                });
            }
            
            console.log(`Cleared ${nodeCount} nodes and ${edgeCount} edges`);
        }
  
        function updateNodeSelection() {
            if (!state.ui.selectedAlter) return;
            
            const selectedId = state.ui.selectedAlter.id;
            
            // Clear previous visual selections first
            d3.selectAll('.alter-node')
                .classed('node--selected', false)
                .classed('node--neighbor', false);
            
            // Get neighbors of selected alter (direct connections only)
            const neighbors = new Set();
            state.current.alterEdges.forEach(edge => {
                if (edge.source === selectedId) neighbors.add(edge.target);
                if (edge.target === selectedId) neighbors.add(edge.source);
            });
            
            // Update all alter nodes with CSS classes
            d3.selectAll('.alter-node').each(function(d) {
                if (!d) return;
                
                const nodeElement = d3.select(this);
                const isSelected = d.id === selectedId;
                const isNeighbor = neighbors.has(d.id);
                
                if (isSelected) {
                    nodeElement.classed('node--selected', true);
                } else if (isNeighbor) {
                    nodeElement.classed('node--neighbor', true);
                }
            });
            
            // Update edges with inline styles - only for current selection
            d3.selectAll('.alter-edge').each(function() {
                const element = d3.select(this);
                const source = element.attr('data-source');
                const target = element.attr('data-target');
                const isConnectedToSelected = source === selectedId || target === selectedId;
                
                if (isConnectedToSelected) {
                    // Apply red styling to selected edges
                    element.style('stroke', '#ef4444')
                          .style('stroke-width', '3.5px')
                          .style('opacity', '0.95');
                } else {
                    // Reset to default styling for non-selected edges
                    element.style('stroke', '#4A5568')
                          .style('stroke-width', '1.5px')
                          .style('opacity', '0.35');
                }
            });
            
            // Bring selected node to front
            d3.selectAll('.alter-node').each(function(d) {
                if (d && d.id === selectedId) {
                    d3.select(this).raise();
                }
            });
        }
  
        function showUnifiedDetails(type, data) {
            // Use fixed details panel instead of floating card
            const panel = document.getElementById('fixedDetailsPanel');
            const title = document.getElementById('fixedDetailsTitle');
            const content = document.getElementById('fixedDetailsContent');
            
            if (type === 'alter') {
                showAlterDetails(title, content, data);
            } else if (type === 'context') {
                showContextDetails(title, content, data.group, data.groupKey);
            }
            
            panel.style.display = 'block';
        }
  
        function showAlterDetails(title, content, alter) {
            title.textContent = 'Selected Alter';
            const d = alter.data;
            
            // Find ties (connections) for this alter
            const alterTies = state.current.alterEdges.filter(edge => 
                edge.source === alter.id || edge.target === alter.id
            ).map(edge => {
                const connectedId = edge.source === alter.id ? edge.target : edge.source;
                const connectedAlter = state.current.alterData.find(a => 
                    normId(a.node_mapping_code) === connectedId
                );
                return connectedAlter ? connectedAlter.node_name || connectedId : connectedId;
            });
  
            // Calculate hours percentage of week
            const weeklyHours = parseFloat(d.node_weekly_hour_summarized || d.node_weekly_hour || 0);
            const hoursPercent = ((weeklyHours / 168) * 100).toFixed(1);
            
            content.innerHTML = `
                <div class="info-row">
                    <span class="info-label">Name:</span>
                    <span class="info-value">${d.node_name || '?'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Role/Relationship:</span>
                    <span class="info-value">${d.node_relationship || d.node_type || '?'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Gender:</span>
                    <span class="info-value">${d.node_gender || '?'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Age:</span>
                    <span class="info-value">${(() => {
                        const isSibling = d.node_type === 'Sibling';
                        const categorizedAge = d.node_age_categorized || 'Unknown';
                        const ageInMonths = d.node_age_in_months;
                        
                        if (isSibling && ageInMonths) {
                            return `${categorizedAge} (${ageInMonths} months)`;
                        } else {
                            return categorizedAge;
                        }
                    })()}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Race:</span>
                    <span class="info-value">${d.node_race || '?'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Language:</span>
                    <span class="info-value">${d.node_language || '?'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Kin:</span>
                    <span class="info-value">${d.node_kin === '1' ? 'Yes' : d.node_kin === '0' ? 'No' : d.node_kin || '?'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Mode of Contact:</span>
                    <span class="info-value">${d.node_mode_of_contact || '?'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Contact Context:</span>
                    <span class="info-value">${parseContactContext(d.node_context) || '?'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Weekly Hours:</span>
                    <span class="info-value">${weeklyHours || '?'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Hours % of week:</span>
                    <span class="info-value">${hoursPercent}%</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Closeness Score:</span>
                    <span class="info-value">${d.node_closeness_score || '?'}</span>
                </div>
                ${alterTies.length > 0 ? `
                    <div style="margin-top: 1rem; border-top: 1px solid #e9ecef; padding-top: 1rem;">
                        <div style="font-weight: 600; margin-bottom: 0.5rem; color: #495057;">Connected To (${alterTies.length}):</div>
                        <div style="font-size: 0.85rem; line-height: 1.4;">
                            ${alterTies.join(', ')}
                        </div>
                    </div>
                ` : ''}
            `;
        }
  
        function showContextDetails(title, content, group, groupKey) {
            title.textContent = `Context Details: ${group.label}`;
            
            let contextDetails = '';
            
            if (group.context === 'daycare') {
                const childData = state.current.childData;
                if (childData) {
                    contextDetails = `
                        <div class="info-row">
                            <span class="info-label">Childcare Type:</span>
                            <span class="info-value">${formatChildcareType(childData.childcare_type)}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Start Age (months):</span>
                            <span class="info-value">${childData.childcare_start_age ? Math.round(parseFloat(childData.childcare_start_age)) : '?'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Group Size:</span>
                            <span class="info-value">${childData.childcare_size ? Math.round(parseFloat(childData.childcare_size)) : '?'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Child Gender:</span>
                            <span class="info-value">${childData.child_gender || '?'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Child Race:</span>
                            <span class="info-value">${childData.child_race || '?'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Language Environment:</span>
                            <span class="info-value">${childData.child_lang || '?'}</span>
                        </div>
                    `;
                }
            } else if (group.context.startsWith('activity_')) {
                const activityId = group.context.split('_')[1];
                const activityData = state.data.activityIndex[state.current.child]?.[activityId];
                
                if (activityData) {
                    contextDetails = `
                        <div class="info-row">
                            <span class="info-label">Activity ID:</span>
                            <span class="info-value">${activityData.activity_id || activityId}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Activity Name:</span>
                            <span class="info-value">${activityData.activity_name || '?'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Other Kids Present:</span>
                            <span class="info-value">${activityData.activity_otherkids_yn || '?'}</span>
                        </div>
                        ${activityData.activity_otherkids_yn === 'Yes' ? `
                        <div class="info-row">
                            <span class="info-label">Number of Other Kids:</span>
                            <span class="info-value">${activityData.activity_otherkids_n || '?'}</span>
                        </div>
                        ` : ''}
                        <div class="info-row">
                            <span class="info-label">Child Age (months):</span>
                            <span class="info-value">${activityData.activity_child_age || '?'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Gender Composition:</span>
                            <span class="info-value">${activityData.activity_gender || '?'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Race Composition:</span>
                            <span class="info-value">${activityData.activity_race || '?'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Contact Type:</span>
                            <span class="info-value">${activityData.activity_contact || '?'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Language Environment:</span>
                            <span class="info-value">${activityData.activity_lang || '?'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Adults Known:</span>
                            <span class="info-value">${activityData.activity_adults || '?'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Kids Known as Friends:</span>
                            <span class="info-value">${activityData.activity_kids || '?'}</span>
                        </div>
                    `;
                }
            }
            
            // List of alters in this context
            const alterList = group.alters.map(alter => {
                const role = alter.data.node_relationship || alter.data.node_type || 'Unknown';
                const respondentMark = isShowingRespondent(alter) ? ' ★' : '';
                return `<div style="margin: 0.25rem 0;">${alter.name}${respondentMark} (${role})</div>`;
            }).join('');
            
            content.innerHTML = `
                ${contextDetails}
                <div style="margin-top: 1.5rem; border-top: 2px solid #e9ecef; padding-top: 1rem;">
                    <div style="font-weight: 600; margin-bottom: 0.75rem; color: #495057;">Alters in this Context (${group.alters.length}):</div>
                    ${alterList}
                </div>
            `;
        }
  
        function positionUnifiedCard(card) {
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const legend = document.getElementById('legend');
            
            // Start with default position - always bottom-right, never center
            let bottom = 20;
            let right = 20;
            
            // Position card and check for legend overlap
            card.style.position = 'fixed';
            card.style.bottom = bottom + 'px';
            card.style.right = right + 'px';
            card.style.left = 'auto';
            card.style.top = 'auto';
            card.style.zIndex = '2000';
            card.style.display = 'block'; // Ensure visible for bbox calculations
            
            // Get bounding boxes for overlap detection
            const cardRect = card.getBoundingClientRect();
            const legendRect = legend.getBoundingClientRect();
            
            // Check for overlap and adjust position iteratively (detect collision and shift left)
            let attempts = 0;
            while (attempts < 5 && cardRect.left < legendRect.right + 10 && 
                   cardRect.bottom > legendRect.top - 10) {
                
                if (windowWidth < 1200) {
                    // On smaller screens, move down first, then left
                    if (attempts < 2) {
                        bottom += 24;
                    } else {
                        right += 24;
                    }
                } else {
                    // On larger screens, move left to avoid legend
                    right += 24;
                }
                
                card.style.bottom = bottom + 'px';
                card.style.right = right + 'px';
                
                // Recalculate after position change
                const newCardRect = card.getBoundingClientRect();
                cardRect.left = newCardRect.left;
                cardRect.bottom = newCardRect.bottom;
                
                attempts++;
            }
            
            // Ensure card doesn't go off-screen (never overlap network area)
            const cardHeight = card.offsetHeight;
            const cardWidth = card.offsetWidth;
            const availableHeight = windowHeight - 40; // Margin from top/bottom
            
            // Prevent covering network area - ensure card stays in UI zone
            const mainContentWidth = windowWidth - 380; // Subtract sidebar width
            if (cardWidth > mainContentWidth * 0.4) { // Max 40% of network area width
                card.style.maxWidth = (mainContentWidth * 0.4) + 'px';
            }
            
            if (cardHeight > availableHeight) {
                card.style.maxHeight = availableHeight + 'px';
                card.style.overflowY = 'auto';
            }
            
            // Ensure minimum distance from edges but keep modest size
            if (right < 20) right = 20;
            if (bottom < 20) bottom = 20;
            
            // Final positioning - always visible but modest
            card.style.bottom = bottom + 'px';
            card.style.right = right + 'px';
        }
  
        function isShowingRespondent(alter) {
            // Check if this alter is the survey respondent
            if (!state.current.childData || !state.current.childData.name_filloutsurvey_1) {
                return false;
            }
            
            const respondentCode = normId(state.current.childData.name_filloutsurvey_1);
            const alterCode = normId(alter.data.node_mapping_code);
            
            return respondentCode && alterCode && respondentCode === alterCode;
        }
  
  
  
        function closeUnifiedDetails() {
            document.getElementById('unifiedDetailsCard').style.display = 'none';
            state.ui.selectedAlter = null;
            state.ui.selectedContext = null;
            state.ui.detailsType = null;
            clearVisualSelection();
        }
  
        function showResizableDetails(alter) {
            const panel = document.getElementById('resizableDetailsPanel');
            const content = document.getElementById('resizableDetailsContent');
            
            if (!alter || !alter.data) {
                panel.style.display = 'none';
                return;
            }
            
            const d = alter.data;
            
            // Build the content HTML
            content.innerHTML = `
                <div class="info-row">
                    <span class="info-label">Name:</span>
                    <span class="info-value">${alter.name || d.node_name || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Role/Relationship:</span>
                    <span class="info-value">${d.node_relationship || d.node_type || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Gender:</span>
                    <span class="info-value">${d.node_gender || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Age:</span>
                    <span class="info-value">${(() => {
                        // For sibling alters, show both categorized age and months if available
                        const isSibling = d.node_type === 'Sibling';
                        const categorizedAge = d.node_age_categorized || 'Unknown';
                        const ageInMonths = d.node_age_in_months;
                        
                        if (isSibling && ageInMonths) {
                            return `${categorizedAge} (${ageInMonths} months)`;
                        } else {
                            return categorizedAge;
                        }
                    })()}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Race:</span>
                    <span class="info-value">${d.node_race || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Language:</span>
                    <span class="info-value">${d.node_language || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Kin:</span>
                    <span class="info-value">${d.node_kin || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Lives at Home:</span>
                    <span class="info-value">${d.node_liveathome_or_not || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Mode of Contact:</span>
                    <span class="info-value">${d.node_mode_of_contact || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Contact Context:</span>
                    <span class="info-value">${parseContactContext(d.node_context)}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Weekly Hours:</span>
                    <span class="info-value">${d.node_weekly_hour_summarized || d.node_weekly_hour || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Hours % of week:</span>
                    <span class="info-value">${d.node_weekly_hour_percent ? d.node_weekly_hour_percent + '%' : 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Closeness Score:</span>
                    <span class="info-value">${d.node_closeness_score || 'N/A'}</span>
                </div>
            `;
            
            // Show the panel
            panel.style.display = 'block';
            
            // Make it draggable and resizable
            makeElementDraggable(panel);
            makeElementResizable(panel);
        }
  
        function closeResizableDetails() {
            document.getElementById('resizableDetailsPanel').style.display = 'none';
        }
  
        function makeElementDraggable(element) {
            let isDragging = false;
            let startX, startY, startLeft, startTop;
            
            const header = element.querySelector('.panel-header');
            
            header.addEventListener('mousedown', function(e) {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startLeft = parseInt(window.getComputedStyle(element).left, 10);
                startTop = parseInt(window.getComputedStyle(element).top, 10);
                
                element.style.cursor = 'grabbing';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                const newLeft = startLeft + (e.clientX - startX);
                const newTop = startTop + (e.clientY - startY);
                
                // Keep panel within viewport bounds
                const maxLeft = window.innerWidth - element.offsetWidth;
                const maxTop = window.innerHeight - element.offsetHeight;
                
                element.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
                element.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';
            });
            
            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    element.style.cursor = 'move';
                }
            });
        }
  
        function makeElementResizable(element) {
            const handles = element.querySelectorAll('.resize-handle');
            
            handles.forEach(handle => {
                handle.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const direction = handle.className.split(' ')[1].replace('resize-handle-', '');
                    const startX = e.clientX;
                    const startY = e.clientY;
                    const startWidth = parseInt(window.getComputedStyle(element).width, 10);
                    const startHeight = parseInt(window.getComputedStyle(element).height, 10);
                    const startLeft = parseInt(window.getComputedStyle(element).left, 10);
                    const startTop = parseInt(window.getComputedStyle(element).top, 10);
                    
                    function doResize(e) {
                        const deltaX = e.clientX - startX;
                        const deltaY = e.clientY - startY;
                        
                        let newWidth = startWidth;
                        let newHeight = startHeight;
                        let newLeft = startLeft;
                        let newTop = startTop;
                        
                        if (direction.includes('e')) {
                            newWidth = Math.max(250, Math.min(500, startWidth + deltaX));
                        }
                        if (direction.includes('w')) {
                            newWidth = Math.max(250, Math.min(500, startWidth - deltaX));
                            newLeft = startLeft + (startWidth - newWidth);
                        }
                        if (direction.includes('s')) {
                            newHeight = Math.max(200, Math.min(window.innerHeight - 100, startHeight + deltaY));
                        }
                        if (direction.includes('n')) {
                            newHeight = Math.max(200, Math.min(window.innerHeight - 100, startHeight - deltaY));
                            newTop = startTop + (startHeight - newHeight);
                        }
                        
                        // Apply constraints to keep panel within viewport
                        if (newLeft < 0) {
                            newWidth += newLeft;
                            newLeft = 0;
                        }
                        if (newTop < 0) {
                            newHeight += newTop;
                            newTop = 0;
                        }
                        if (newLeft + newWidth > window.innerWidth) {
                            newWidth = window.innerWidth - newLeft;
                        }
                        if (newTop + newHeight > window.innerHeight) {
                            newHeight = window.innerHeight - newTop;
                        }
                        
                        element.style.width = newWidth + 'px';
                        element.style.height = newHeight + 'px';
                        element.style.left = newLeft + 'px';
                        element.style.top = newTop + 'px';
                        
                        // Update content area height to maintain scrolling
                        const content = element.querySelector('.panel-content');
                        if (content) {
                            const headerHeight = 60; // Approximate header height
                            const contentHeight = newHeight - headerHeight;
                            content.style.height = Math.max(200, contentHeight) + 'px';
                        }
                    }
                    
                    function stopResize() {
                        document.removeEventListener('mousemove', doResize);
                        document.removeEventListener('mouseup', stopResize);
                    }
                    
                    document.addEventListener('mousemove', doResize);
                    document.addEventListener('mouseup', stopResize);
                });
            });
        }
  
        function closeFixedDetails() {
            document.getElementById('fixedDetailsPanel').style.display = 'none';
            state.ui.selectedAlter = null;
            state.ui.selectedContext = null;
            state.ui.detailsType = null;
            clearVisualSelection();
        }
  
        function showAlterInfoInSidebar(alter) {
            selectAlter(alter);
        }
  
        function showAlterInfo(alter) {
            const panel = document.getElementById('alterPanel');
            const content = document.getElementById('alterContent');
            const d = alter.data;
            
            content.innerHTML = `
                <div class="info-row">
                    <span class="info-label">Name:</span>
                    <span class="info-value">${d.node_name || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Type:</span>
                    <span class="info-value">${d.node_type || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Relationship:</span>
                    <span class="info-value">${d.node_relationship || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Context:</span>
                    <span class="info-value">${parseContactContext(d.node_context)}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Gender:</span>
                    <span class="info-value">${d.node_gender || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Age:</span>
                    <span class="info-value">${(() => {
                        const isSibling = d.node_type === 'Sibling';
                        const categorizedAge = d.node_age_categorized || 'Unknown';
                        const ageInMonths = d.node_age_in_months;
                        
                        if (isSibling && ageInMonths) {
                            return `${categorizedAge} (${ageInMonths} months)`;
                        } else {
                            return categorizedAge;
                        }
                    })()}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Race:</span>
                    <span class="info-value">${d.node_race || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Language:</span>
                    <span class="info-value">${d.node_language || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Kin:</span>
                    <span class="info-value">${d.node_kin || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Lives at Home:</span>
                    <span class="info-value">${d.node_liveathome_or_not || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Weekly Hours:</span>
                    <span class="info-value">${d.node_weekly_hour_summarized || d.node_weekly_hour || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Closeness Score:</span>
                    <span class="info-value">${d.node_closeness_score || 'N/A'}</span>
                </div>
            `;
            
            showPanel(panel);
        }
  
        function showEgoInfo() {
            // Show child info section in sidebar instead of floating panel
            showSidebarSection('child-info');
        }
  
        function showPanel(panel) {
            // Hide all panels first
            document.querySelectorAll('.info-panel').forEach(p => p.style.display = 'none');
            
            // Show selected panel
            panel.style.display = 'block';
            panel.style.left = '50px';
            panel.style.top = '100px';
        }
  
        function closePanel(panelId) {
            document.getElementById(panelId).style.display = 'none';
        }
  
  
  
        // Event handlers
        document.addEventListener('click', function(event) {
            // Close panels when clicking outside
            if (!event.target.closest('.info-panel') && 
                !event.target.closest('.floating-card') &&
                !event.target.closest('.fixed-details-panel') &&
                !event.target.closest('.resizable-details-panel') &&
                !event.target.closest('.context-box') && 
                !event.target.closest('.alter-node') &&
                !event.target.closest('.ego-node')) {
                // Close all panels
                document.querySelectorAll('.info-panel').forEach(panel => {
                    panel.style.display = 'none';
                });
                document.getElementById('unifiedDetailsCard').style.display = 'none';
                document.getElementById('fixedDetailsPanel').style.display = 'none';
                document.getElementById('resizableDetailsPanel').style.display = 'none';
                
                // Clear selection
                clearSelection();
            }
        });
  
        // Keyboard event handlers
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                // Close modals and panels
                document.getElementById('sampleModal').style.display = 'none';
                document.getElementById('helpOverlay').style.display = 'none';
                
                if (state.ui.page === 'child') {
                    // Close all panels and clear selection in child dashboard
                    document.querySelectorAll('.info-panel').forEach(panel => {
                        panel.style.display = 'none';
                    });
                    document.getElementById('unifiedDetailsCard').style.display = 'none';
                    document.getElementById('fixedDetailsPanel').style.display = 'none';
                    clearSelection();
                }
            } else if (event.key === 'Enter') {
                // Handle Enter key for primary actions on each page
                if (state.ui.page === 'welcome') {
                    const processBtn = document.getElementById('processBtn');
                    if (processBtn && !processBtn.disabled) {
                        processData();
                    }
                } else if (state.ui.page === 'validate') {
                    const continueBtn = document.getElementById('continueBtn');
                    if (continueBtn && !continueBtn.disabled) {
                        goToMode();
                    }
                } else if (state.ui.page === 'mode') {
                    startChildExploration();
                } else if (state.ui.page === 'child' && (state.ui.selectedAlter || state.ui.selectedContext)) {
                    // Toggle right panel for accessibility in child dashboard
                    const alterSection = document.getElementById('alterDetailsSection');
                    if (alterSection.style.display === 'none' && state.ui.selectedAlter) {
                        showAlterInfoInSidebar(state.ui.selectedAlter);
                    } else {
                        alterSection.style.display = 'none';
                    }
                }
            }
        });
  
          function normalizeRace(rawRace) {
         if (!rawRace) return ['Unknown'];
         
         const raceMap = {
             'white': 'White',
             'black': 'Black',
             'african': 'Black',
             'african american': 'Black',
             'hisp': 'Hispanic/Latino',
             'latino': 'Hispanic/Latino',
             'latinx': 'Hispanic/Latino',
             'hispanic': 'Hispanic/Latino',
             'asian': 'Asian',
             'native': 'Native/Alaska',
             'alaska': 'Native/Alaska',
             'american indian': 'Native/Alaska',
             'middle east': 'MENA',
             'mena': 'MENA',
             'north africa': 'MENA',
             'mixed': 'Multiracial',
             'multi': 'Multiracial',
             'multiracial': 'Multiracial',
             'unknown': 'Unknown'
         };
         
         const normalized = rawRace.split(/[,;/|]+/)
             .map(race => race.trim().toLowerCase())
             .map(race => {
                 for (const [key, value] of Object.entries(raceMap)) {
                     if (race.includes(key)) return value;
                 }
                 return 'Other';
             })
             .filter((race, index, arr) => arr.indexOf(race) === index); // Remove duplicates
         
         // Return up to first 3 races for pie charts
         const result = normalized.slice(0, 3);
         return result.length > 0 ? result : ['Unknown'];
     }
  
    // Prefer node_relationship_intensity_z, fallback to node_closeness_intensity_z
    // Utility: shrink text to fit within a circle radius
    function fitTextToCircle(textNode, radius) {
        if (!textNode) return;
        const maxWidth = radius * 1.6;
        let size = parseFloat(textNode.style.fontSize || '13');
        const minSize = 8;
        while (size > minSize && textNode.getComputedTextLength() > maxWidth) {
            size -= 1;
            textNode.style.fontSize = size + 'px';
        }
        if (textNode.getComputedTextLength() > maxWidth) {
            let t = textNode.textContent;
            while (t.length > 1 && textNode.getComputedTextLength() > maxWidth) {
                t = t.slice(0, -1);
                textNode.textContent = t + '…';
            }
        }
    }
  
    function getClosenessIntensityZFromData(d) {
        const v = parseFloat(
            d?.node_relationship_intensity_z ?? d?.node_closeness_intensity_z ?? 0
        );
        return isNaN(v) ? 0 : v;
    }
  
    // Sidebar navigation function
    function showSidebarSection(sectionId) {
        // Hide all sections
        document.querySelectorAll('.sidebar-section').forEach(section => {
            section.style.display = 'none';
        });
        
        // Remove active class from all tabs
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.classList.remove('active');
        });
        
        // Show selected section
        const section = document.getElementById(sectionId);
        if (section) {
            section.style.display = 'block';
        }
        
        // Add active class to clicked tab
        event.target.classList.add('active');
        
        // Update child info when switching to that tab
        if (sectionId === 'child-info') {
            updateSidebarChildInfo();
        }
        
        // Update network stats when switching to stats tab
        if (sectionId === 'network-stats') {
            updateNetworkStats();
        }
        
        // Handle explore whole data tab
        if (sectionId === 'explore-whole-data') {
            // Show exploration plots area
            const explorationPlotsArea = document.getElementById('explorationPlotsArea');
            if (explorationPlotsArea) {
                explorationPlotsArea.style.display = 'block';
            }
            
            // Hide network visualization
            const networkSvg = document.getElementById('networkSvg');
            if (networkSvg) {
                networkSvg.style.display = 'none';
            }
            
            // Hide legend
            const legend = document.getElementById('legend');
            if (legend) {
                legend.style.display = 'none';
            }
        } else {
            // Show network visualization for other tabs
            const explorationPlotsArea = document.getElementById('explorationPlotsArea');
            if (explorationPlotsArea) {
                explorationPlotsArea.style.display = 'none';
            }
            
            const networkSvg = document.getElementById('networkSvg');
            if (networkSvg) {
                networkSvg.style.display = 'block';
            }
            
            const legend = document.getElementById('legend');
            if (legend) {
                legend.style.display = 'block';
            }
        }
    }
  
  
  
  
  
    // Update child info in sidebar
    function updateSidebarChildInfo() {
        const container = document.getElementById('sidebarChildInfo');
        const childData = state.current.childData;
        
        if (!childData) {
            container.innerHTML = '<div style="color: #6c757d; font-style: italic;">Select a child to view information</div>';
        } else {
            container.innerHTML = `
                <div class="info-row">
                    <span class="info-label">Name:</span>
                    <span class="info-value">${childData.child_name || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Age:</span>
                    <span class="info-value">${childData.age_in_months || 'N/A'} months</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Gender:</span>
                    <span class="info-value">${childData.child_gender || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Race:</span>
                    <span class="info-value">${childData.child_race || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Language:</span>
                    <span class="info-value">${childData.child_lang || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Birth Date:</span>
                    <span class="info-value">${childData.birthdate || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Network Size:</span>
                    <span class="info-value">${state.current.alterData?.length || 0} alters</span>
                </div>
            `;
        }
          }
        
        // ===== ENHANCED EXPLORE WHOLE DATA FUNCTIONS =====
        
        function initializeWholeDataExploration() {
            console.log('Initializing whole data exploration');
            console.log('Current state:', state);
            
            // Populate interaction variable dropdowns
            populateWholeDataInteractionVariables();
            
            // Show welcome message initially
            document.getElementById('wholeDataPlotsArea').style.display = 'none';
            document.getElementById('wholeDataWelcome').style.display = 'block';
            
            // Check if data is available
            if (state.data.networkWide && state.data.longDf && state.data.activityLong) {
                console.log('All datasets are available');
                console.log('Network wide data sample:', state.data.networkWide.slice(0, 2));
                console.log('Long df data sample:', state.data.longDf.slice(0, 2));
                console.log('Activity long data sample:', state.data.activityLong.slice(0, 2));
            } else {
                console.log('Some datasets are missing');
                console.log('Network wide:', !!state.data.networkWide);
                console.log('Long df:', !!state.data.longDf);
                console.log('Activity long:', !!state.data.activityLong);
            }
        }
        
        function updateWholeDataExplorationView() {
            const mode = document.getElementById('wholeDataExplorationMode').value;
            const distributionControls = document.getElementById('wholeDataDistributionControls');
            const interactionControls = document.getElementById('wholeDataInteractionControls');
            const distributionPlot = document.getElementById('wholeDataDistributionPlot');
            const interactionPlot = document.getElementById('wholeDataInteractionPlot');
            const plotsArea = document.getElementById('wholeDataPlotsArea');
            const welcome = document.getElementById('wholeDataWelcome');
            
            // Show/hide controls based on mode
            if (mode === 'distribution') {
                distributionControls.style.display = 'block';
                interactionControls.style.display = 'none';
                distributionPlot.style.display = 'block';
                interactionPlot.style.display = 'none';
            } else {
                distributionControls.style.display = 'none';
                interactionControls.style.display = 'block';
                distributionPlot.style.display = 'none';
                interactionPlot.style.display = 'block';
            }
            
            // Show plots area and hide welcome
            plotsArea.style.display = 'block';
            welcome.style.display = 'none';
        }
        
        function updateWholeDataDistributionPlot() {
            const variable = document.getElementById('wholeDataDistributionVariable').value;
            if (!variable) return;
            
            console.log('Updating distribution plot for variable:', variable);
            
            // Get data for the selected variable
            const data = getWholeDataVariableData(variable);
            console.log('Data retrieved:', data);
            
            if (!data) {
                alert('No data available for this variable');
                return;
            }
            
            // Create the plot
            createWholeDataDistributionPlot(variable, data);
            
            // Update summary statistics
            updateWholeDataDistributionStats(variable, data);
        }
        
        function updateWholeDataInteractionPlot() {
            const xVar = document.getElementById('wholeDataXVariable').value;
            const yVar = document.getElementById('wholeDataYVariable').value;
            
            if (!xVar || !yVar) return;
            
            // Get data for both variables
            const xData = getWholeDataVariableData(xVar);
            const yData = getWholeDataVariableData(yVar);
            
            if (!xData || !yData) {
                alert('No data available for selected variables');
                return;
            }
            
            // Create the interaction plot
            createWholeDataInteractionPlot(xVar, yVar, xData, yData);
            
            // Update interaction statistics
            updateWholeDataInteractionStats(xVar, yVar, xData, yData);
        }
        
        function getWholeDataVariableData(variable) {
            console.log('Getting data for variable:', variable);
            console.log('State data available:', {
                networkWide: !!state.data.networkWide,
                longDf: !!state.data.longDf,
                activityLong: !!state.data.activityLong
            });
            
            // Check if data is available
            if (!state.data.networkWide || !state.data.longDf || !state.data.activityLong) {
                console.log('Missing required datasets - providing sample data for testing');
                
                // Provide sample data for testing when real data isn't available
                return getSampleDataForVariable(variable);
            }
            
            // Direct columns from network_wide
            if (variable in state.data.networkWide[0]) {
                console.log('Found direct variable in network_wide');
                let data = state.data.networkWide.map(row => row[variable]);
                
                // Special handling for language variables
                if (variable === 'child_lang') {
                    data = categorizeLanguageData(data);
                }
                
                console.log('Direct data:', data);
                return data;
            }
            
            // Derived metrics from long_df
            if (variable.startsWith('sibling_') || variable.startsWith('kin_') || 
                variable.startsWith('extended_') || variable.startsWith('caregiver_') ||
                variable.startsWith('live_at_home_') || variable.startsWith('pct_') ||
                variable.startsWith('avg_') || variable.startsWith('max_') || 
                variable.startsWith('min_') || variable.startsWith('exposure_') ||
                variable.startsWith('mode_of_contact_')) {
                console.log('Calculating derived metrics for:', variable);
                const data = calculateDerivedMetrics(variable);
                console.log('Derived data:', data);
                return data;
            }
            
            // Activity-based metrics
            if (variable.startsWith('activity_')) {
                console.log('Calculating activity metrics for:', variable);
                const data = calculateActivityMetrics(variable);
                console.log('Activity data:', data);
                return data;
            }
            
            console.log('Variable not found in any dataset - providing sample data');
            return getSampleDataForVariable(variable);
        }
        
        function getSampleDataForVariable(variable) {
            console.log('Providing sample data for:', variable);
            
            // Generate sample data for testing
            const sampleData = {
                'age_in_months': [23, 14, 25, 18, 22, 19, 21, 16, 24, 20],
                'child_gender': ['Female', 'Female', 'Male', 'Male', 'Female', 'Male', 'Female', 'Male', 'Female', 'Male'],
                'network_size': [14, 7, 12, 9, 15, 11, 13, 8, 16, 10],
                'network_density': [0.29, 0.29, 0.31, 0.28, 0.30, 0.32, 0.27, 0.33, 0.26, 0.34],
                'sibling_size': [2, 1, 3, 1, 2, 1, 2, 1, 3, 1],
                'kin_size': [4, 2, 5, 3, 4, 2, 4, 3, 5, 2],
                'extended_family_presence': [1, 0, 1, 1, 0, 1, 1, 0, 1, 1],
                'caregiver_presence': [1, 1, 0, 1, 1, 0, 1, 1, 0, 1],
                'live_at_home_size': [3, 2, 4, 2, 3, 2, 3, 2, 4, 2],
                'avg_closeness_score': [0.5, 0.3, 0.7, 0.4, 0.6, 0.3, 0.5, 0.4, 0.6, 0.3],
                'activity_count': [2, 1, 3, 1, 2, 1, 2, 1, 3, 1],
                'activity_diversity': [2, 1, 3, 1, 2, 1, 2, 1, 3, 1],
                'child_lang': ['English Only', 'Bilingual', 'Multilingual', 'Exposure', 'English Only', 'Bilingual', 'Multilingual', 'Exposure', 'English Only', 'Bilingual'],
                'childcare_type': ['Day care center', 'Licensed family day care', 'Family child care', 'In-home care', 'Nanny']
            };
            
            return sampleData[variable] || [1, 2, 3, 4, 5]; // Default fallback
        }
        
        function categorizeLanguageData(languageData) {
            console.log('Categorizing language data:', languageData);
            
            return languageData.map(lang => {
                if (!lang || lang === '') return 'Unknown';
                
                // Convert to string and get first word
                const firstWord = String(lang).trim().split(/[,\s;]+/)[0].toLowerCase();
                
                console.log('Processing language:', lang, 'First word:', firstWord);
                
                // Categorize based on first word
                if (firstWord === 'english') {
                    return 'English Only';
                } else if (firstWord === 'multilingual') {
                    return 'Multilingual';
                } else if (firstWord === 'bilingual') {
                    return 'Bilingual';
                } else if (firstWord === 'exposure' || firstWord === 'limited' || firstWord === 'basic') {
                    return 'Exposure';
                } else {
                    // If it's not English, it's likely multilingual or bilingual
                    return 'Multilingual';
                }
            });
        }
        
        function calculateDerivedMetrics(variable) {
            const metrics = {};
            
            state.data.networkWide.forEach(child => {
                const childId = child.ChildID;
                const childLongData = state.data.longDf.filter(row => row.ChildID === childId);
                
                switch (variable) {
                    case 'sibling_size':
                        metrics[childId] = childLongData.filter(row => row.node_relationship === 'Brother' || row.node_relationship === 'Sister' || row.node_relationship === 'Little brother' || row.node_relationship === 'Older brother').length;
                        break;
                    case 'kin_size':
                        const kinRelationships = ['Brother', 'Sister', 'Little brother', 'Older brother', 'Cousin', 'Aunt', 'Uncle', 'Grandma', 'Grandpa'];
                        metrics[childId] = childLongData.filter(row => kinRelationships.includes(row.node_relationship)).length;
                        break;
                    case 'extended_family_presence':
                        const extendedRelationships = ['Cousin', 'Aunt', 'Uncle', 'Grandma', 'Grandpa'];
                        metrics[childId] = childLongData.some(row => extendedRelationships.includes(row.node_relationship)) ? 1 : 0;
                        break;
                    case 'caregiver_presence':
                        metrics[childId] = childLongData.some(row => row.node_relationship === 'Nanny' || row.node_relationship === 'Caregiver') ? 1 : 0;
                        break;
                    case 'live_at_home_size':
                        metrics[childId] = childLongData.filter(row => row.node_liveathome_or_not === 'yes').length;
                        break;
                    case 'avg_closeness_score':
                        const closenessScores = childLongData.map(row => row.node_closeness_score).filter(score => !isNaN(score));
                        metrics[childId] = closenessScores.length > 0 ? d3.mean(closenessScores) : 0;
                        break;
                    case 'max_closeness_score':
                        const maxScores = childLongData.map(row => row.node_closeness_score).filter(score => !isNaN(score));
                        metrics[childId] = maxScores.length > 0 ? d3.max(maxScores) : 0;
                        break;
                    case 'min_closeness_score':
                        const minScores = childLongData.map(row => row.node_closeness_score).filter(score => !isNaN(score));
                        metrics[childId] = minScores.length > 0 ? d3.min(minScores) : 0;
                        break;
                    case 'avg_weekly_exposure':
                        const exposures = childLongData.map(row => row.node_weekly_hour_percent).filter(exposure => !isNaN(exposure));
                        metrics[childId] = exposures.length > 0 ? d3.mean(exposures) : 0;
                        break;
                    case 'pct_male_alters':
                        const maleAlters = childLongData.filter(row => row.node_gender === 'Male').length;
                        const totalAlters = childLongData.length;
                        metrics[childId] = totalAlters > 0 ? (maleAlters / totalAlters) * 100 : 0;
                        break;
                    case 'pct_female_alters':
                        const femaleAlters = childLongData.filter(row => row.node_gender === 'Female').length;
                        const totalAlters2 = childLongData.length;
                        metrics[childId] = totalAlters2 > 0 ? (femaleAlters / totalAlters2) * 100 : 0;
                        break;
                }
            });
            
            return Object.values(metrics);
        }
        
        function calculateActivityMetrics(variable) {
            const metrics = {};
            
            state.data.networkWide.forEach(child => {
                const childId = child.ChildID;
                const childActivityData = state.data.activityLong.filter(row => row.childID === childId);
                
                switch (variable) {
                    case 'activity_count':
                        metrics[childId] = childActivityData.length;
                        break;
                    case 'activity_diversity':
                        const uniqueActivities = new Set(childActivityData.map(row => row.activity_name));
                        metrics[childId] = uniqueActivities.size;
                        break;
                    case 'pct_activities_with_peers':
                        const withPeers = childActivityData.filter(row => row.activity_otherkids_yn === 'yes').length;
                        metrics[childId] = childActivityData.length > 0 ? (withPeers / childActivityData.length) * 100 : 0;
                        break;
                }
            });
            
            return Object.values(metrics);
        }
        
        function createWholeDataDistributionPlot(variable, data) {
            const chartDiv = document.getElementById('wholeDataDistributionChart');
            
            // Clear previous content
            chartDiv.innerHTML = '';
            
            console.log('Creating distribution plot for:', variable, 'with data:', data);
            
            // Check if data is continuous or categorical
            const isContinuous = typeof data[0] === 'number' && !isNaN(data[0]);
            console.log('Data type detection - isContinuous:', isContinuous, 'first value:', data[0], 'type:', typeof data[0]);
            
            if (isContinuous) {
                console.log('Creating histogram for continuous data');
                createWholeDataHistogram(chartDiv, variable, data);
            } else {
                console.log('Creating bar chart for categorical data');
                createWholeDataBarChart(chartDiv, variable, data);
            }
        }
        
        function createWholeDataHistogram(container, variable, data) {
            console.log('Creating histogram for:', variable, 'with data:', data);
            
            // Validate data
            if (!data || !Array.isArray(data) || data.length === 0) {
                console.error('Invalid data for histogram:', data);
                container.innerHTML = '<p style="color: red; text-align: center; padding: 20px;">No data available for this variable</p>';
                return;
            }
            
            // Filter out undefined, null, or NaN values for numeric data
            const validData = data.filter(d => d !== undefined && d !== null && !isNaN(d));
            console.log('Valid numeric data after filtering:', validData);
            
            if (validData.length === 0) {
                container.innerHTML = '<p style="color: red; text-align: center; padding: 20px;">No valid numeric data available for this variable</p>';
                return;
            }
            
            // Create histogram using D3.js with ggplot-like styling
            const margin = {top: 30, right: 30, bottom: 50, left: 70};
            const width = container.offsetWidth - margin.left - margin.right;
            const height = 350 - margin.top - margin.bottom;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Create scales
            const x = d3.scaleLinear()
                .domain([d3.min(validData), d3.max(validData)])
                .range([0, width]);
            
            const y = d3.scaleLinear()
                .domain([0, d3.max(d3.histogram().domain(x.domain()).thresholds(x.ticks(20))(validData))])
                .range([height, 0]);
            
            // Create histogram
            const histogram = d3.histogram()
                .domain(x.domain())
                .thresholds(x.ticks(20));
            
            const bins = histogram(validData);
            
            // Add grid lines
            svg.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).tickSize(-height).tickFormat(''));
            
            svg.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(y).tickSize(-width).tickFormat(''));
            
            // Add bars with ggplot-like styling
            svg.selectAll('rect')
                .data(bins)
                .enter().append('rect')
                .attr('x', d => x(d.x0))
                .attr('width', d => Math.max(0, x(d.x1) - x(d.x0) - 1))
                .attr('y', d => y(d.length))
                .attr('height', d => height - y(d.length))
                .style('fill', '#3b82f6')
                .style('stroke', '#1e40af')
                .style('stroke-width', '1px')
                .style('opacity', 0.8);
            
            // Add axes with clean styling
            const xAxis = d3.axisBottom(x);
            const yAxis = d3.axisLeft(y);
            
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(xAxis)
                .style('font-size', '12px');
            
            svg.append('g')
                .call(yAxis)
                .style('font-size', '12px');
            
            // Add labels
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height + margin.bottom - 10)
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', '600')
                .style('fill', '#374151')
                .text(variable.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));
            
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left + 20)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', '600')
                .style('fill', '#374151')
                .text('Frequency');
            
            // Style grid lines
            svg.selectAll('.grid line')
                .style('stroke', '#e5e7eb')
                .style('stroke-width', '1px')
                .style('opacity', 0.5);
        }
        
        function createWholeDataBarChart(container, variable, data) {
            console.log('Creating bar chart for:', variable, 'with data:', data);
            
            // Validate data
            if (!data || !Array.isArray(data) || data.length === 0) {
                console.error('Invalid data for bar chart:', data);
                container.innerHTML = '<p style="color: red; text-align: center; padding: 20px;">No data available for this variable</p>';
                return;
            }
            
            // Filter out undefined, null, or empty values
            const validData = data.filter(d => d !== undefined && d !== null && d !== '');
            console.log('Valid data after filtering:', validData);
            
            if (validData.length === 0) {
                container.innerHTML = '<p style="color: red; text-align: center; padding: 20px;">No valid data available for this variable</p>';
                return;
            }
            
            // Create bar chart using D3.js with ggplot-like styling
            const margin = {top: 30, right: 30, bottom: 50, left: 70};
            const width = container.offsetWidth - margin.left - margin.right;
            const height = 350 - margin.top - margin.bottom;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Count frequencies
            const counts = {};
            validData.forEach(d => {
                const key = String(d); // Convert to string to handle any data type
                counts[key] = (counts[key] || 0) + 1;
            });
            
            console.log('Counts object:', counts);
            
            const categories = Object.keys(counts);
            const frequencies = Object.values(counts);
            
            console.log('Categories:', categories);
            console.log('Frequencies:', frequencies);
            
            // Create scales
            const x = d3.scaleBand()
                .domain(categories)
                .range([0, width])
                .padding(0.1);
            
            const y = d3.scaleLinear()
                .domain([0, d3.max(frequencies)])
                .range([height, 0]);
            
            // Handle long category labels by truncating them
            const truncatedCategories = categories.map(cat => {
                if (cat.length > 20) {
                    return cat.substring(0, 17) + '...';
                }
                return cat;
            });
            
            // Add grid lines
            svg.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(y).tickSize(-width).tickFormat(''));
            
            // Add bars with ggplot-like styling
            svg.selectAll('rect')
                .data(categories)
                .enter().append('rect')
                .attr('x', d => x(d))
                .attr('width', x.bandwidth())
                .attr('y', d => y(counts[d]))
                .attr('height', d => height - y(counts[d]))
                .style('fill', '#3b82f6')
                .style('stroke', '#1e40af')
                .style('stroke-width', '1px')
                .style('opacity', 0.8);
            
            // Add value labels on bars
            svg.selectAll('text')
                .data(categories)
                .enter().append('text')
                .attr('x', d => x(d) + x.bandwidth() / 2)
                .attr('y', d => y(counts[d]) - 5)
                .attr('text-anchor', 'middle')
                .style('font-size', '12px')
                .style('font-weight', '600')
                .style('fill', '#374151')
                .text(d => counts[d]);
            
            // Add axes with clean styling
            const xAxis = d3.axisBottom(x);
            const yAxis = d3.axisLeft(y);
            
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(xAxis)
                .style('font-size', '12px');
            
            svg.append('g')
                .call(yAxis)
                .style('font-size', '12px');
            
            // Add labels
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height + margin.bottom - 10)
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', '600')
                .style('fill', '#374151')
                .text(variable.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));
            
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left + 20)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', '600')
                .style('fill', '#374151')
                .text('Count');
            
            // Style grid lines
            svg.selectAll('.grid line')
                .style('stroke', '#e5e7eb')
                .style('stroke-width', '1px')
                .style('opacity', 0.5);
        }
        
        function createWholeDataInteractionPlot(xVar, yVar, xData, yData) {
            const chartDiv = document.getElementById('wholeDataInteractionChart');
            
            // Clear previous content
            chartDiv.innerHTML = '';
            
            // Check if both variables are continuous
            const xContinuous = typeof xData[0] === 'number';
            const yContinuous = typeof yData[0] === 'number';
            
            if (xContinuous && yContinuous) {
                createWholeDataScatterPlot(chartDiv, xVar, yVar, xData, yData);
            } else if (xContinuous || yContinuous) {
                createWholeDataBoxPlot(chartDiv, xVar, yVar, xData, yData);
            } else {
                createWholeDataHeatmap(chartDiv, xVar, yVar, xData, yData);
            }
        }
        
        function createWholeDataScatterPlot(container, xVar, yVar, xData, yData) {
            // Create scatter plot using D3.js with ggplot-like styling and regression line
            const margin = {top: 30, right: 30, bottom: 50, left: 70};
            const width = container.offsetWidth - margin.left - margin.right;
            const height = 350 - margin.top - margin.bottom;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Create scales
            const x = d3.scaleLinear()
                .domain([d3.min(xData), d3.max(xData)])
                .range([0, width]);
            
            const y = d3.scaleLinear()
                .domain([d3.min(yData), d3.max(yData)])
                .range([height, 0]);
            
            // Add grid lines
            svg.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).tickSize(-height).tickFormat(''));
            
            svg.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(y).tickSize(-width).tickFormat(''));
            
            // Calculate regression line
            const regression = calculateRegression(xData, yData);
            
            // Add regression line
            if (regression) {
                const line = d3.line()
                    .x(d => x(d.x))
                    .y(d => y(d.y));
                
                const lineData = [
                    {x: d3.min(xData), y: regression.slope * d3.min(xData) + regression.intercept},
                    {x: d3.max(xData), y: regression.slope * d3.max(xData) + regression.intercept}
                ];
                
                svg.append('path')
                    .datum(lineData)
                    .attr('fill', 'none')
                    .attr('stroke', '#ef4444')
                    .attr('stroke-width', '2px')
                    .attr('stroke-dasharray', '5,5')
                    .attr('d', line);
            }
            
            // Add dots with ggplot-like styling
            svg.selectAll('circle')
                .data(xData.map((d, i) => ({x: d, y: yData[i]})))
                .enter().append('circle')
                .attr('cx', d => x(d.x))
                .attr('cy', d => y(d.y))
                .attr('r', 4)
                .style('fill', '#3b82f6')
                .style('stroke', '#1e40af')
                .style('stroke-width', '1px')
                .style('opacity', 0.7);
            
            // Add axes with clean styling
            const xAxis = d3.axisBottom(x);
            const yAxis = d3.axisLeft(y);
            
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(xAxis)
                .style('font-size', '12px');
            
            svg.append('g')
                .call(yAxis)
                .style('font-size', '12px');
            
            // Add labels
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height + margin.bottom - 10)
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', '600')
                .style('fill', '#374151')
                .text(xVar.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));
            
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left + 20)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', '600')
                .style('fill', '#374151')
                .text(yVar.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));
            
            // Style grid lines
            svg.selectAll('.grid line')
                .style('stroke', '#e5e7eb')
                .style('stroke-width', '1px')
                .style('opacity', 0.5);
        }
        
        function updateWholeDataDistributionStats(variable, data) {
            const statsDiv = document.getElementById('wholeDataDistributionStats');
            
            if (typeof data[0] === 'number') {
                // Continuous variable
                const n = data.length;
                const mean = d3.mean(data);
                const median = d3.median(data);
                const std = d3.deviation(data);
                const q1 = d3.quantile(data, 0.25);
                const q3 = d3.quantile(data, 0.75);
                
                statsDiv.innerHTML = `
                    <div><strong>N:</strong> ${n}</div>
                    <div><strong>Mean:</strong> ${mean.toFixed(2)}</div>
                    <div><strong>SD:</strong> ${std.toFixed(2)}</div>
                    <div><strong>Median:</strong> ${median.toFixed(2)}</div>
                    <div><strong>Q1:</strong> ${q1.toFixed(2)}</div>
                    <div><strong>Q3:</strong> ${q3.toFixed(2)}</div>
                `;
            } else {
                // Categorical variable
                const counts = {};
                data.forEach(d => {
                    counts[d] = (counts[d] || 0) + 1;
                });
                
                const total = data.length;
                let statsHTML = `<div><strong>Total:</strong> ${total}</div>`;
                
                Object.entries(counts).forEach(([category, count]) => {
                    const proportion = (count / total * 100).toFixed(1);
                    statsHTML += `<div><strong>${category}:</strong> ${count} (${proportion}%)</div>`;
                });
                
                statsDiv.innerHTML = statsHTML;
            }
        }
        
        function updateWholeDataInteractionStats(xVar, yVar, xData, yData) {
            const statsDiv = document.getElementById('wholeDataInteractionStats');
            
            if (typeof xData[0] === 'number' && typeof yData[0] === 'number') {
                // Both continuous - calculate correlation and regression
                const correlation = calculateCorrelation(xData, yData);
                const regression = calculateRegression(xData, yData);
                const rSquared = correlation * correlation;
                
                statsDiv.innerHTML = `
                    <div><strong>Correlation (r):</strong> ${correlation.toFixed(3)}</div>
                    <div><strong>R²:</strong> ${rSquared.toFixed(3)}</div>
                    <div><strong>Slope:</strong> ${regression ? regression.slope.toFixed(3) : 'N/A'}</div>
                    <div><strong>Intercept:</strong> ${regression ? regression.intercept.toFixed(3) : 'N/A'}</div>
                    <div><strong>N:</strong> ${xData.length}</div>
                `;
            } else {
                statsDiv.innerHTML = `<div>Select variables to view relationship statistics</div>`;
            }
        }
        
        function calculateRegression(x, y) {
            const n = x.length;
            if (n < 2) return null;
            
            const sumX = d3.sum(x);
            const sumY = d3.sum(y);
            const sumXY = d3.sum(x.map((d, i) => d * y[i]));
            const sumX2 = d3.sum(x.map(d => d * d));
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            return { slope, intercept };
        }
        
        function calculateCorrelation(x, y) {
            const n = x.length;
            const sumX = d3.sum(x);
            const sumY = d3.sum(y);
            const sumXY = d3.sum(x.map((d, i) => d * y[i]));
            const sumX2 = d3.sum(x.map(d => d * d));
            const sumY2 = d3.sum(y.map(d => d * d));
            
            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
            
            return denominator === 0 ? 0 : numerator / denominator;
        }
        
        // Add missing D3.js functions if they don't exist
        if (typeof d3.quantile === 'undefined') {
            d3.quantile = function(array, p) {
                if (!array || array.length === 0) return undefined;
                const sorted = array.slice().sort((a, b) => a - b);
                const index = (sorted.length - 1) * p;
                const lower = Math.floor(index);
                const upper = Math.ceil(index);
                const weight = index - lower;
                if (upper === lower) return sorted[lower];
                return sorted[lower] * (1 - weight) + sorted[upper] * weight;
            };
        }
        
        if (typeof d3.deviation === 'undefined') {
            d3.deviation = function(array) {
                const mean = d3.mean(array);
                const squareDiffs = array.map(value => Math.pow(value - mean, 2));
                const avgSquareDiff = d3.mean(squareDiffs);
                return Math.sqrt(avgSquareDiff);
            };
        }
        
        function exportWholeDataPlot() {
            const format = document.getElementById('wholeDataExportFormat').value;
            
            if (format === 'csv') {
                // Export data as CSV
                const mode = document.getElementById('wholeDataExplorationMode').value;
                if (mode === 'distribution') {
                    const variable = document.getElementById('wholeDataDistributionVariable').value;
                    const data = getWholeDataVariableData(variable);
                
                if (data) {
                    const csvContent = `Variable,Value\n${data.map(d => `${variable},${d}`).join('\n')}`;
                    const blob = new Blob([csvContent], {type: 'text/csv'});
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${variable}_data.csv`;
                    a.click();
                    window.URL.revokeObjectURL(url);
                    }
                } else {
                    const xVar = document.getElementById('wholeDataXVariable').value;
                    const yVar = document.getElementById('wholeDataYVariable').value;
                    const xData = getWholeDataVariableData(xVar);
                    const yData = getWholeDataVariableData(yVar);
                    
                    if (xData && yData) {
                        const csvContent = `X_Variable,Y_Variable\n${xData.map((d, i) => `${d},${yData[i] || ''}`).join('\n')}`;
                        const blob = new Blob([csvContent], {type: 'text/csv'});
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${xVar}_vs_${yVar}_data.csv`;
                        a.click();
                        window.URL.revokeObjectURL(url);
                    }
                }
            } else {
                // Export plot as image
                const mode = document.getElementById('wholeDataExplorationMode').value;
                let chartDiv;
                
                if (mode === 'distribution') {
                    chartDiv = document.getElementById('wholeDataDistributionChart');
                } else {
                    chartDiv = document.getElementById('wholeDataInteractionChart');
                }
                
                if (chartDiv && chartDiv.querySelector('svg')) {
                    html2canvas(chartDiv, {
                        backgroundColor: 'white',
                        scale: 2
                    }).then(canvas => {
                        const link = document.createElement('a');
                        link.download = `whole_data_plot.${format}`;
                        link.href = canvas.toDataURL(`image/${format}`);
                        link.click();
                    });
                }
            }
        }
        
        // Populate whole data interaction variable dropdowns
        function populateWholeDataInteractionVariables() {
            const xSelect = document.getElementById('wholeDataXVariable');
            const ySelect = document.getElementById('wholeDataYVariable');
            const distributionSelect = document.getElementById('wholeDataDistributionVariable');
            
            // Copy options from distribution variable
            xSelect.innerHTML = distributionSelect.innerHTML;
            ySelect.innerHTML = distributionSelect.innerHTML;
        }
        
        // Add missing box plot and heatmap functions
        function createWholeDataBoxPlot(container, xVar, yVar, xData, yData) {
            // Create box plot for categorical x continuous y
            const margin = {top: 30, right: 30, bottom: 50, left: 70};
            const width = container.offsetWidth - margin.left - margin.right;
            const height = 350 - margin.top - margin.bottom;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Group data by x variable
            const groups = {};
            xData.forEach((x, i) => {
                if (!groups[x]) groups[x] = [];
                groups[x].push(yData[i]);
            });
            
            const categories = Object.keys(groups);
            const x = d3.scaleBand()
                .domain(categories)
                .range([0, width])
                .padding(0.1);
            
            const y = d3.scaleLinear()
                .domain([d3.min(yData), d3.max(yData)])
                .range([height, 0]);
            
            // Add grid lines
            svg.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(y).tickSize(-width).tickFormat(''));
            
            // Create box plots for each group
            categories.forEach(category => {
                const data = groups[category];
                const q1 = d3.quantile(data, 0.25);
                const median = d3.median(data);
                const q3 = d3.quantile(data, 0.75);
                const iqr = q3 - q1;
                const lowerWhisker = Math.max(q1 - 1.5 * iqr, d3.min(data));
                const upperWhisker = Math.min(q3 + 1.5 * iqr, d3.max(data));
                
                const xPos = x(category) + x.bandwidth() / 2;
                
                // Draw whiskers
                svg.append('line')
                    .attr('x1', xPos)
                    .attr('x2', xPos)
                    .attr('y1', y(lowerWhisker))
                    .attr('y2', y(upperWhisker))
                    .style('stroke', '#374151')
                    .style('stroke-width', '2px');
                
                // Draw box
                svg.append('rect')
                    .attr('x', x(category) + x.bandwidth() * 0.2)
                    .attr('y', y(q3))
                    .attr('width', x.bandwidth() * 0.6)
                    .attr('height', y(q1) - y(q3))
                    .style('fill', '#3b82f6')
                    .style('stroke', '#1e40af')
                    .style('stroke-width', '1px');
                
                // Draw median line
                svg.append('line')
                    .attr('x1', x(category) + x.bandwidth() * 0.2)
                    .attr('x2', x(category) + x.bandwidth() * 0.8)
                    .attr('y1', y(median))
                    .attr('y2', y(median))
                    .style('stroke', '#ef4444')
                    .style('stroke-width', '2px');
            });
            
            // Add axes
            const xAxis = d3.axisBottom(x);
            const yAxis = d3.axisLeft(y);
            
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(xAxis)
                .style('font-size', '12px');
            
            svg.append('g')
                .call(yAxis)
                .style('font-size', '12px');
            
            // Add labels
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height + margin.bottom - 10)
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', '600')
                .style('fill', '#374151')
                .text(xVar.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));
            
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left + 20)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', '600')
                .style('fill', '#374151')
                .text(yVar.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));
            
            // Style grid lines
            svg.selectAll('.grid line')
                .style('stroke', '#e5e7eb')
                .style('stroke-width', '1px')
                .style('opacity', 0.5);
        }
        
        function createWholeDataHeatmap(container, xVar, yVar, xData, yData) {
            // Create heatmap for categorical x categorical y
            const margin = {top: 30, right: 30, bottom: 50, left: 70};
            const width = container.offsetWidth - margin.left - margin.right;
            const height = 350 - margin.top - margin.bottom;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Count co-occurrences
            const counts = {};
            xData.forEach((x, i) => {
                const y = yData[i];
                if (!counts[x]) counts[x] = {};
                if (!counts[x][y]) counts[x][y] = 0;
                counts[x][y]++;
            });
            
            const xCategories = [...new Set(xData)];
            const yCategories = [...new Set(yData)];
            
            const x = d3.scaleBand()
                .domain(xCategories)
                .range([0, width])
                .padding(0.1);
            
            const y = d3.scaleBand()
                .domain(yCategories)
                .range([0, height])
                .padding(0.1);
            
            const colorScale = d3.scaleSequential()
                .domain([0, d3.max(Object.values(counts).flatMap(obj => Object.values(obj)))])
                .interpolator(d3.interpolateBlues);
            
            // Add cells
            xCategories.forEach(xCat => {
                yCategories.forEach(yCat => {
                    const count = counts[xCat]?.[yCat] || 0;
                    svg.append('rect')
                        .attr('x', x(xCat))
                        .attr('y', y(yCat))
                        .attr('width', x.bandwidth())
                        .attr('height', y.bandwidth())
                        .style('fill', colorScale(count))
                        .style('stroke', '#e5e7eb')
                        .style('stroke-width', '1px');
                    
                    // Add count labels
                    if (count > 0) {
                        svg.append('text')
                            .attr('x', x(xCat) + x.bandwidth() / 2)
                            .attr('y', y(yCat) + y.bandwidth() / 2)
                            .attr('text-anchor', 'middle')
                            .attr('dy', '0.35em')
                            .style('font-size', '12px')
                            .style('font-weight', '600')
                            .style('fill', count > 3 ? 'white' : '#374151')
                            .text(count);
                    }
                });
            });
            
            // Add axes
            const xAxis = d3.axisBottom(x);
            const yAxis = d3.axisLeft(y);
            
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(xAxis)
                .style('font-size', '12px');
            
            svg.append('g')
                .call(yAxis)
                .style('font-size', '12px');
            
            // Add labels
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height + margin.bottom - 10)
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', '600')
                .style('fill', '#374151')
                .text(xVar.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));
            
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left + 20)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', '600')
                .style('fill', '#374151')
                .text(yVar.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));
        }
        
        // Screenshot function for whole data page
        function takeWholeDataScreenshot() {
            const format = document.getElementById('wholeDataScreenshotFormat').value;
            const container = document.querySelector('.whole-data-page .dashboard-container');
            
            if (container) {
                html2canvas(container, {
                    backgroundColor: 'white',
                    scale: 2
                }).then(canvas => {
                    const link = document.createElement('a');
                    link.download = `whole_data_dashboard.${format}`;
                    link.href = canvas.toDataURL(`image/${format}`);
                    link.click();
                });
            }
        }
        
        // Header control functions for whole data page
        function toggleWholeDataHeader() {
            console.log('toggleWholeDataHeader called');
            const breadcrumb = document.getElementById('wholeDataBreadcrumb');
            const toggleIcon = document.getElementById('wholeDataToggleIcon');
            
            console.log('Breadcrumb element:', breadcrumb);
            console.log('Toggle icon element:', toggleIcon);
            
            if (!breadcrumb || !toggleIcon) {
                console.error('Header elements not found');
                return;
            }
            
            if (breadcrumb.classList.contains('collapsed')) {
                console.log('Expanding header');
                breadcrumb.classList.remove('collapsed');
                toggleIcon.textContent = '▼';
            } else {
                console.log('Collapsing header');
                breadcrumb.classList.add('collapsed');
                toggleIcon.textContent = '▲';
            }
        }
        
        function startWholeDataHeaderDrag(event) {
            event.preventDefault();
            event.stopPropagation();
            
            const breadcrumb = document.getElementById('wholeDataBreadcrumb');
            if (!breadcrumb) return;
            
            // Store initial position
            const initialLeft = parseInt(breadcrumb.style.left) || 400;
            const initialTop = parseInt(breadcrumb.style.top) || 80;
            
            // Store mouse start position
            const mouseStartX = event.clientX;
            const mouseStartY = event.clientY;
            
            breadcrumb.classList.add('dragging');
            
            function onMouseMove(e) {
                const deltaX = e.clientX - mouseStartX;
                const deltaY = e.clientY - mouseStartY;
                
                const newLeft = initialLeft + deltaX;
                const newTop = initialTop + deltaY;
                
                // Keep within viewport bounds
                const maxLeft = window.innerWidth - breadcrumb.offsetWidth;
                const maxTop = window.innerHeight - breadcrumb.offsetHeight;
                
                breadcrumb.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
                breadcrumb.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';
            }
            
            function onMouseUp() {
                breadcrumb.classList.remove('dragging');
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }
        
                // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize existing functionality
            if (typeof populateInteractionVariables === 'function') {
                populateInteractionVariables();
            }
            
            // Initialize edge visibility setting
            if (!state.ui.edgeVisibility) {
                state.ui.edgeVisibility = 'all';
                console.log('Initialized edge visibility to:', state.ui.edgeVisibility);
            }
            
            // Test header controls functionality
            setTimeout(() => {
                console.log('Testing header controls...');
                const wholeDataBreadcrumb = document.getElementById('wholeDataBreadcrumb');
                const childBreadcrumb = document.getElementById('breadcrumb');
                
                if (wholeDataBreadcrumb) {
                    console.log('Whole data breadcrumb found:', wholeDataBreadcrumb);
                }
                if (childBreadcrumb) {
                    console.log('Child breadcrumb found:', childBreadcrumb);
                }
            }, 1000);
        });
    </script>
  
  
  
  </body></html>
